This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
_docs/
  GameplayDesign.md
  latency.md
  physics.md
  SFX.md
  style.md
.cursor/
  rules/
    godot.mdc
    multiplayer.mdc
    physics.mdc
    process-task-list.mdc
.godot/
  editor/
    Balloon Escape Factory.mp3-54140b5b2b11b7904ee81e622b8af5f7.mp3str-folding-cdca4a205518c9274cf8e6ba790f32f2.cfg
    Balloon Escape Factory.mp3-a84b0e9981ac63b9aa18472c4c340af6.mp3str-folding-189a8f541b4a47fd3971a4d9e3b7a11f.cfg
    bounce.mp3-40b4ac2a57340ad0a4800cce652f4adb.mp3str-folding-e343cc0128b6db116f9f30a762935757.cfg
    bounce.mp3-c83954d43e882cf41da4bb95039bb03d.mp3str-folding-55516b02daf01392d8688f4b8f89f64a.cfg
    coins.mp3-7dc50d0b845a91d46fb5cdd74a20d161.mp3str-folding-c548d5c5b19d7a3fbf8e66c2f4daf8e6.cfg
    coins.mp3-f6db493078653e3c3432ef7bfd892903.mp3str-folding-0d64863fe8d3bf25fbe0912c7454e90f.cfg
    editor_layout.cfg
    filesystem_cache8
    filesystem_update4
    GameState.gd-folding-18d7ecab4510ccd8943d878b726087f6.cfg
    Kenney Future Narrow.ttf-453e2fa23c1cd4a37e88d1e6aae31b2a.fontdata-folding-e8d1a76080fa29997781299cdf990c02.cfg
    Kenney Future Narrow.ttf-ef7e34836d9e5dc059ca737da9380cb7.fontdata-folding-fbd84f9eb9b2e81eef7a82dcac6d5cba.cfg
    Kenney Future.ttf-3e4bff56a5c053e0f32b5e9c961621bc.fontdata-folding-1dc8bd670ad06fa27f164dd8a4ce2ca2.cfg
    Kenney Future.ttf-845b8d86f13614effd75cae8b9fe56b9.fontdata-folding-2078c0616cf77b597ab5727e162309d4.cfg
    player.gd-folding-f3e766a223e56b2d62acb89340e64980.cfg
    player.tscn-editstate-c2c62cb8c73458cd122faf659769dc80.cfg
    player.tscn-folding-c2c62cb8c73458cd122faf659769dc80.cfg
    pop.mp3-67e17343cda83c66845025dcce55cb20.mp3str-folding-9bc5f4cf8ad755cc90b7ee014331c3a4.cfg
    pop.mp3-8a0c1ee8b23ba0bce4af1df1b73a2c47.mp3str-folding-e15f8994f0fa46149533a1fdf0bc16a2.cfg
    project_metadata.cfg
    script_editor_cache.cfg
    success.mp3-2f4cfc1e2ce208c30d0192cb1e366d1a.mp3str-folding-fb8faa49ddd5890251ea8d15ba9b3111.cfg
    success.mp3-8c2123d5a82507e48393b4843ef40866.mp3str-folding-c5c275bd1e1bdf5c4dcf5f6917521fc5.cfg
  imported/
    ball.png-b42bc1a78430fc3412eda843a2d529ba.md5
    ball.png-b8e6aa06c746a4928b1493a1566800b7.md5
    Balloon Escape Factory.mp3-54140b5b2b11b7904ee81e622b8af5f7.md5
    Balloon Escape Factory.mp3-a84b0e9981ac63b9aa18472c4c340af6.md5
    bg_layer1.png-448a8143e3892073d6b96852c0d29f68.md5
    bg_layer1.png-d7aad465b3d677b057046413bf620986.md5
    bounce.mp3-40b4ac2a57340ad0a4800cce652f4adb.md5
    bounce.mp3-c83954d43e882cf41da4bb95039bb03d.md5
    coins.mp3-7dc50d0b845a91d46fb5cdd74a20d161.md5
    coins.mp3-f6db493078653e3c3432ef7bfd892903.md5
    gold_1.png-ce85689bdf1a2e894fb7bb02067050f8.md5
    gold_1.png-db46b66b9e6ef0a985206ce30f386ed4.md5
    gold_2.png-8ade76d86f08dbc818f88c105df709be.md5
    gold_2.png-ceeb5eec4d9a8f3664fa8cc38cccf4bf.md5
    gold_3.png-07ceaf45def4d2d47fac62b91b6517bd.md5
    gold_3.png-2a0ca9d63e62ff045778d59d9dc377b6.md5
    ground_stone_broken.png-031ff3db296cf9afe9884f044f68cea2.md5
    ground_stone_broken.png-951b10430d8294a08834f774aad0677a.md5
    ground_stone_small_broken.png-46a5bcba6bc2926e8e42011cd9cb8aed.md5
    ground_stone_small_broken.png-cb7fc31b3ff9f21e979b6b81794fe6b7.md5
    ground_stone_small.png-1e2024afc10899f6d1e3e5da3365e4af.md5
    ground_stone_small.png-4849dc2b09040fa5788ce9d24d033840.md5
    ground_stone.png-0bd443f60f21a15810f7368646956ffa.md5
    ground_stone.png-6b1440ca0d40ac663187ab858a651c21.md5
    ground_wood_broken.png-dd276242039b45259ccad59065be77d5.md5
    ground_wood_broken.png-df96d7686bdd747217995967851dabb2.md5
    ground_wood_small_broken.png-a3587c5b407e85fc3c7e2b68de2d7274.md5
    ground_wood_small_broken.png-a3c0fbd05c9702f0c8ef67962b913ec0.md5
    ground_wood_small.png-7ecffbe7ca5b3c5d7ccda9e262cbc169.md5
    ground_wood_small.png-bdbad7e757dd8c52068ca768c451bb41.md5
    ground_wood.png-a52d13af3cc19d314dd0d09e450484f2.md5
    ground_wood.png-f0b3d2229bc74c48d3c01145bf6f093f.md5
    jetpack_item.png-40a582ff252f95b4aa8ef6e65241ffa5.md5
    jetpack_item.png-f60f7b9d86b86072d4f6e05fe8211f10.md5
    jetpack.png-a07c4cb1b95f9ce3f872c85465ade680.md5
    jetpack.png-b90b6e87e060ca5cd324a9f77391caac.md5
    Kenney Future Narrow.ttf-453e2fa23c1cd4a37e88d1e6aae31b2a.md5
    Kenney Future Narrow.ttf-ef7e34836d9e5dc059ca737da9380cb7.md5
    Kenney Future.ttf-3e4bff56a5c053e0f32b5e9c961621bc.md5
    Kenney Future.ttf-845b8d86f13614effd75cae8b9fe56b9.md5
    lives_coin_bronze.png-48dc32bdc49e21e82bb6f174160bbae0.md5
    lives_coin_bronze.png-c491644430900a183d49ff9bcbd16664.md5
    platformPack_tile004.png-2852e78ff4503106706ebe0cb367ee72.md5
    platformPack_tile004.png-7fab26bba6cb2b1d4d9e3512bc743172.md5
    platformPack_tile034.png-ca4f4ece287a50142c6225506b38c7e0.md5
    platformPack_tile034.png-d97ff266769a529eba2b47dff49109d9.md5
    pop.mp3-67e17343cda83c66845025dcce55cb20.md5
    pop.mp3-8a0c1ee8b23ba0bce4af1df1b73a2c47.md5
    spike_bottom.png-7e81a852e91320387fd73ac54e59bb59.md5
    spike_bottom.png-d4a2d1ad0907cee71e5f3da55815a9e9.md5
    spike_top.png-bd6769f098435c26d87d62df69144db0.md5
    spike_top.png-fddb7c9aab302afc8a9417c3c88e618b.md5
    spikes_bottom.png-0a54744ef319b9879b095ea552cd3a17.md5
    spikes_bottom.png-dfa63a25199c2cb2532dcedfd88f6b3d.md5
    spikes_top.png-60600659598e52a36081d7f594544828.md5
    spikes_top.png-964376e5763eee2d0812fdf4e21c3998.md5
    spring_in.png-7fc5f83a8c532c37407fef680d2036b9.md5
    spring_in.png-98f4981fd80b3a227b4c3f8bf2a6a5f4.md5
    spring_out.png-10ccb538d5372629a0ba43253a98a552.md5
    spring_out.png-6c0d3ee6db38931f4d254dbd7db9d984.md5
    spring.png-617f1f030d57217fdc379e07d6cd255d.md5
    spring.png-7c80b20e3ee39a78bddbc31742b8c47e.md5
    success.mp3-2f4cfc1e2ce208c30d0192cb1e366d1a.md5
    success.mp3-8c2123d5a82507e48393b4843ef40866.md5
  .gdignore
  global_script_class_cache.cfg
  import_md5.md5
assets/
  audio/
    Balloon Escape Factory.mp3.import
    bounce.mp3.import
    coins.mp3.import
    pop.mp3.import
    success.mp3.import
BopAssets/
  SFX/
    Balloon Escape Factory.mp3.import
    bounce.mp3.import
    coins.mp3.import
    pop.mp3.import
    success.mp3.import
scenes/
  levels/
    mvp_test.tscn
  player/
    player.tscn
scripts/
  player/
    player.gd
  singletons/
    GameState.gd
    SoundManager.gd
    SoundManager.tscn
tasks/
  DevelopmentPlan.md
project.godot
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="_docs/latency.md">
---

### **Action Plan: Mitigating Latency in "Bop"**

This is a step-by-step plan to build your multiplayer architecture in a way that actively hides network latency from the players. Follow these instructions in order.

#### **Part 1: Implementing Client-Side Prediction (For a Responsive Player)**

**Goal:** To make the player's own character feel instantly responsive, ignoring network lag.

1.  **Read Local Input First:**
    *   In your `Player.gd` script's `_physics_process` function, create an `if` block that only runs for the player you control: `if is_multiplayer_authority():`.

2.  **Apply Immediate Movement:**
    *   Inside this `if` block, read the keyboard input (e.g., `Input.get_axis("move_left", "move_right")`).
    *   **Immediately** apply force or set the velocity on the player's `RigidBody2D` using this input. This is the "prediction" step. The ball will move on your screen instantly without waiting for the server.

3.  **Create an RPC to Announce Input:**
    *   Create a new function called `submit_player_input(direction)` and mark it with the `@rpc` annotation. This function will announce the player's *intent* to the server.
    *   `@rpc("any_peer", "reliable")`
    *   `func submit_player_input(direction: float):`
        *   `self.horizontal_intent = direction`

4.  **Call the RPC:**
    *   Inside the `if is_multiplayer_authority():` block from Step 1, after you've read the keyboard input, call the RPC to send your input to the server: `submit_player_input.rpc(direction)`.

---

#### **Part 2: Implementing Server Reconciliation (To Correct Predictions)**

**Goal:** To ensure the game remains synchronized by having the server correct any mistakes made by the client's prediction.

1.  **Process Input on the Server:**
    *   The `submit_player_input` RPC you created will run on the server when a client calls it.
    *   On the server, use the `horizontal_intent` variable set by the RPC to apply movement to its authoritative copy of the player. The server now has the "correct" game state.

2.  **Synchronize Authoritative State:**
    *   Add a `MultiplayerSynchronizer` node as a child of your `Player.tscn`.
    *   In the Inspector for this node, add the `global_position` property to the list of "Replicated Properties."

3.  **Check for and Correct Errors on the Client:**
    *   In your `Player.gd`'s `_physics_process` function (outside the `if is_multiplayer_authority():` block), compare the client's predicted position with the authoritative position being received from the `MultiplayerSynchronizer`.
    *   If the distance between the two positions is larger than a small tolerance (e.g., a few pixels), smoothly move (lerp) or snap the client's player ball to the server's position. This "reconciliation" step corrects any prediction errors and prevents the game from drifting out of sync.

---

#### **Part 3: Implementing Interpolation (For Smooth Opponents)**

**Goal:** To make other players (the ones you are not controlling) appear to move smoothly across your screen instead of stuttering or teleporting.

1.  **Trust the `MultiplayerSynchronizer`:**
    *   This is the simplest part. For any `Player` instance where `is_multiplayer_authority()` is `false` (i.e., your opponent), you do not need to write any custom movement logic.

2.  **Do Not Apply Manual Movement:**
    *   Ensure your `_physics_process` loop does not apply any velocity or force to these "puppet" nodes.
    *   The `MultiplayerSynchronizer` you configured in Part 2 will automatically receive position updates from the server for these nodes and smoothly interpolate them between their last known position and their new position. This creates the illusion of fluid, real-time movement. Your only job is to let it work.
</file>

<file path=".cursor/rules/process-task-list.mdc">
---
description: Guidelines for managing task lists in markdown files to track progress on completing a PRD
globs: **/tasks/**/*.md, **/tasks-*.md
---

# Task List Management

// Description: Guidelines for managing task lists in markdown files to track progress on completing a PRD
// Recommended Globs: **/tasks/**/*.md, **/tasks-*.md

Guidelines for managing task lists in markdown files to track progress on completing a PRD

## Task Implementation
- **One sub-task at a time:** Do **NOT** start the next sub‑task until you ask the user for permission and they say "yes" or "y"
- **Completion protocol:**
  1. When you finish a **sub‑task**, immediately mark it as completed by changing `[ ]` to `[x]`.
  2. If **all** subtasks underneath a parent task are now `[x]`, also mark the **parent task** as completed.
- Stop after each sub‑task and wait for the user's go‑ahead.

## Task List Maintenance

1. **Update the task list as you work:**
   - Mark tasks and subtasks as completed (`[x]`) per the protocol above.
   - Add new tasks as they emerge.

2. **Maintain the "Relevant Files" section:**
   - List every file created or modified.
   - Give each file a one‑line description of its purpose.

## AI Instructions

When working with task lists, the AI must:

1. Regularly update the task list file after finishing any significant work.
2. Follow the completion protocol:
   - Mark each finished **sub‑task** `[x]`.
   - Mark the **parent task** `[x]` once **all** its subtasks are `[x]`.
3. Add newly discovered tasks.
4. Keep "Relevant Files" accurate and up to date.
5. Before starting work, check which sub‑task is next.
6. After implementing a sub‑task, update the file and then pause for user approval.
</file>

<file path=".godot/editor/Balloon Escape Factory.mp3-54140b5b2b11b7904ee81e622b8af5f7.mp3str-folding-cdca4a205518c9274cf8e6ba790f32f2.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/Balloon Escape Factory.mp3-a84b0e9981ac63b9aa18472c4c340af6.mp3str-folding-189a8f541b4a47fd3971a4d9e3b7a11f.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/bounce.mp3-40b4ac2a57340ad0a4800cce652f4adb.mp3str-folding-e343cc0128b6db116f9f30a762935757.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/bounce.mp3-c83954d43e882cf41da4bb95039bb03d.mp3str-folding-55516b02daf01392d8688f4b8f89f64a.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/coins.mp3-7dc50d0b845a91d46fb5cdd74a20d161.mp3str-folding-c548d5c5b19d7a3fbf8e66c2f4daf8e6.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/coins.mp3-f6db493078653e3c3432ef7bfd892903.mp3str-folding-0d64863fe8d3bf25fbe0912c7454e90f.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/editor_layout.cfg">
[docks]

dock_3_selected_tab_idx=0
dock_4_selected_tab_idx=0
dock_5_selected_tab_idx=0
dock_floating={}
dock_bottom=[]
dock_closed=[]
dock_split_2=0
dock_split_3=0
dock_hsplit_1=0
dock_hsplit_2=540
dock_hsplit_3=-540
dock_hsplit_4=0
dock_filesystem_h_split_offset=480
dock_filesystem_v_split_offset=0
dock_filesystem_display_mode=0
dock_filesystem_file_sort=0
dock_filesystem_file_list_display_mode=1
dock_filesystem_selected_paths=PackedStringArray("res://scripts/singletons/GameState.gd")
dock_filesystem_uncollapsed_paths=PackedStringArray("Favorites", "res://", "res://scripts/", "res://scripts/singletons/", "res://scripts/player/", "res://scenes/")
dock_3="Scene,Import"
dock_4="FileSystem"
dock_5="Inspector,Node,History"

[EditorNode]

open_scenes=PackedStringArray("res://scenes/player/player.tscn")
current_scene="res://scenes/player/player.tscn"
center_split_offset=0
selected_default_debugger_tab_idx=0
selected_main_editor_idx=2

[ScriptEditor]

open_scripts=["res://scripts/singletons/GameState.gd", "res://scripts/player/player.gd"]
selected_script="res://scripts/singletons/GameState.gd"
open_help=[]
script_split_offset=140
list_split_offset=0
zoom_factor=1.0

[ShaderEditor]

open_shaders=[]
split_offset=0
selected_shader=""
text_shader_zoom_factor=1.0
</file>

<file path=".godot/editor/filesystem_cache8">
ea4bc82a6ad023ab7ee23ee620429895
::res://::1752610159
::res://_docs/::1752608397
GameplayDesign.md::TextFile::-1::1752596949::0::1::::<><>::
physics.md::TextFile::-1::1752601040::0::1::::<><>::
SFX.md::TextFile::-1::1752608420::0::1::::<><>::
style.md::TextFile::-1::1752608054::0::1::::<><>::
::res://assets/::1752609848
::res://assets/audio/::1752609863
Balloon Escape Factory.mp3::AudioStreamMP3::8206070679105260282::1752609863::1752610161::1::::<><>::
bounce.mp3::AudioStreamMP3::9107122368181559716::1752609863::1752610161::1::::<><>::
coins.mp3::AudioStreamMP3::7901847376389709318::1752609863::1752610161::1::::<><>::
pop.mp3::AudioStreamMP3::2058950163202925655::1752609863::1752610161::1::::<><>::
success.mp3::AudioStreamMP3::3151194912288285675::1752609863::1752610161::1::::<><>::
::res://assets/fonts/::1752609863
Kenney Future Narrow.ttf::FontFile::8513457004296160927::1752609863::1752610161::1::::<><>::
Kenney Future.ttf::FontFile::1191888830290857463::1752609863::1752610161::1::::<><>::
::res://assets/materials/::1752609848
::res://assets/sprites/::1752609863
::res://assets/sprites/background/::1752609863
bg_layer1.png::CompressedTexture2D::9055781292271014096::1752609863::1752610161::1::::<><>::
::res://assets/sprites/collectibles_and_powerups/::1752609863
gold_1.png::CompressedTexture2D::7770782626171002347::1752609863::1752610161::1::::<><>::
gold_2.png::CompressedTexture2D::4961529463577090600::1752609863::1752610161::1::::<><>::
gold_3.png::CompressedTexture2D::197269280592586432::1752609863::1752610161::1::::<><>::
jetpack.png::CompressedTexture2D::2475813519409685781::1752609863::1752610161::1::::<><>::
jetpack_item.png::CompressedTexture2D::5246885340615533327::1752609863::1752610161::1::::<><>::
::res://assets/sprites/environment/::1752609863
ground_stone.png::CompressedTexture2D::6376627101721888681::1752609863::1752610161::1::::<><>::
ground_stone_broken.png::CompressedTexture2D::1217873350915114682::1752609863::1752610161::1::::<><>::
ground_stone_small.png::CompressedTexture2D::1898771885991249189::1752609863::1752610161::1::::<><>::
ground_stone_small_broken.png::CompressedTexture2D::1934413432216654678::1752609863::1752610161::1::::<><>::
ground_wood.png::CompressedTexture2D::165595163471498862::1752609863::1752610161::1::::<><>::
ground_wood_broken.png::CompressedTexture2D::1881575544315897996::1752609863::1752610161::1::::<><>::
ground_wood_small.png::CompressedTexture2D::3549772765016810542::1752609863::1752610161::1::::<><>::
ground_wood_small_broken.png::CompressedTexture2D::6660159512624062090::1752609863::1752610161::1::::<><>::
platformPack_tile004.png::CompressedTexture2D::5893765852238350109::1752609863::1752610161::1::::<><>::
platformPack_tile034.png::CompressedTexture2D::1199564023964960820::1752609863::1752610161::1::::<><>::
::res://assets/sprites/hazards/::1752609863
spikes_bottom.png::CompressedTexture2D::4645057525981595265::1752609863::1752610161::1::::<><>::
spikes_top.png::CompressedTexture2D::8203667586019862508::1752609863::1752610161::1::::<><>::
spike_bottom.png::CompressedTexture2D::6486924403349916602::1752609863::1752610161::1::::<><>::
spike_top.png::CompressedTexture2D::1952382968673477592::1752609863::1752610161::1::::<><>::
spring.png::CompressedTexture2D::57287654817836701::1752609863::1752610161::1::::<><>::
spring_in.png::CompressedTexture2D::8022793080425135513::1752609863::1752610161::1::::<><>::
spring_out.png::CompressedTexture2D::7851334279652825319::1752609863::1752610161::1::::<><>::
::res://assets/sprites/player/::1752609863
ball.png::CompressedTexture2D::8220970251950762316::1752609863::1752610161::1::::<><>::
::res://assets/sprites/ui/::1752609863
lives_coin_bronze.png::CompressedTexture2D::5825732135293081176::1752609863::1752610161::1::::<><>::
::res://BopAssets/::1752607920
::res://BopAssets/assets/::1752604419
::res://BopAssets/assets/background/::1752604419
bg_layer1.png::CompressedTexture2D::6945879680719127106::1438633120::1752610161::1::::<><>::
::res://BopAssets/assets/collectibles_and_powerups/::1752602541
gold_1.png::CompressedTexture2D::1825224882516228972::1438630844::1752610161::1::::<><>::
gold_2.png::CompressedTexture2D::1190387119302935012::1438630844::1752610161::1::::<><>::
gold_3.png::CompressedTexture2D::2512755368299904449::1438630844::1752610161::1::::<><>::
jetpack.png::CompressedTexture2D::2931813711614556912::1438630844::1752610161::1::::<><>::
jetpack_item.png::CompressedTexture2D::7878243431060436377::1438630844::1752610161::1::::<><>::
::res://BopAssets/assets/environment/::1752602747
ground_stone.png::CompressedTexture2D::547254746964749841::1438630844::1752610161::1::::<><>::
ground_stone_broken.png::CompressedTexture2D::7182484478301215561::1438630844::1752610161::1::::<><>::
ground_stone_small.png::CompressedTexture2D::5920530557858546565::1438630844::1752610161::1::::<><>::
ground_stone_small_broken.png::CompressedTexture2D::6862542807011331575::1438630844::1752610161::1::::<><>::
ground_wood.png::CompressedTexture2D::2762796157845493017::1438630844::1752610161::1::::<><>::
ground_wood_broken.png::CompressedTexture2D::1920911236381604898::1438630844::1752610161::1::::<><>::
ground_wood_small.png::CompressedTexture2D::5259545193054983935::1438630844::1752610161::1::::<><>::
ground_wood_small_broken.png::CompressedTexture2D::2167022817881405705::1438630844::1752610161::1::::<><>::
platformPack_tile004.png::CompressedTexture2D::4959656382865155942::1473016014::1752610161::1::::<><>::
platformPack_tile034.png::CompressedTexture2D::2691896846324894211::1473016016::1752610161::1::::<><>::
::res://BopAssets/assets/hazards/::1752602461
spikes_bottom.png::CompressedTexture2D::663950830898210423::1438630844::1752610161::1::::<><>::
spikes_top.png::CompressedTexture2D::8358873055094092465::1438630844::1752610161::1::::<><>::
spike_bottom.png::CompressedTexture2D::3883150255362487646::1438630844::1752610161::1::::<><>::
spike_top.png::CompressedTexture2D::2459527082247234580::1438630844::1752610161::1::::<><>::
spring.png::CompressedTexture2D::4173908731025172797::1438630844::1752610161::1::::<><>::
spring_in.png::CompressedTexture2D::6480400973107942546::1438630844::1752610161::1::::<><>::
spring_out.png::CompressedTexture2D::2318680103272890803::1438630844::1752610161::1::::<><>::
::res://BopAssets/assets/player/::1752602241
ball.png::CompressedTexture2D::7132219559505673927::1752598976::1752610161::1::::<><>::
::res://BopAssets/assets/ui/::1752604534
lives_coin_bronze.png::CompressedTexture2D::3399006749739018670::1438630844::1752610161::1::::<><>::
::res://BopAssets/font/::1752603166
Kenney Future Narrow.ttf::FontFile::7000552542377076331::1509903390::1752610161::1::::<><>::
Kenney Future.ttf::FontFile::5090768802296251228::1509902930::1752610161::1::::<><>::
::res://BopAssets/SFX/::1752607968
Balloon Escape Factory.mp3::AudioStreamMP3::8415698812563648905::1752607954::1752610161::1::::<><>::
bounce.mp3::AudioStreamMP3::3881155579214223749::1752606679::1752610161::1::::<><>::
coins.mp3::AudioStreamMP3::4713675940845734844::1752606782::1752610161::1::::<><>::
pop.mp3::AudioStreamMP3::4996625001048486516::1752606733::1752610161::1::::<><>::
success.mp3::AudioStreamMP3::3071999385586472187::1752606857::1752610161::1::::<><>::
::res://scenes/::1752609848
::res://scenes/effects/::1752609848
::res://scenes/levels/::1752609848
::res://scenes/main_menu/::1752609848
::res://scenes/player/::1752609848
::res://scenes/ui/::1752609848
::res://scripts/::1752609848
::res://scripts/effects/::1752609848
::res://scripts/player/::1752609848
::res://scripts/singletons/::1752609848
::res://scripts/ui/::1752609848
</file>

<file path=".godot/editor/filesystem_update4">
res://scenes/player/player.tscn
res://scripts/singletons/GameState.gd
res://scripts/player/player.gd
</file>

<file path=".godot/editor/GameState.gd-folding-18d7ecab4510ccd8943d878b726087f6.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/Kenney Future Narrow.ttf-453e2fa23c1cd4a37e88d1e6aae31b2a.fontdata-folding-e8d1a76080fa29997781299cdf990c02.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/Kenney Future Narrow.ttf-ef7e34836d9e5dc059ca737da9380cb7.fontdata-folding-fbd84f9eb9b2e81eef7a82dcac6d5cba.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/Kenney Future.ttf-3e4bff56a5c053e0f32b5e9c961621bc.fontdata-folding-1dc8bd670ad06fa27f164dd8a4ce2ca2.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/Kenney Future.ttf-845b8d86f13614effd75cae8b9fe56b9.fontdata-folding-2078c0616cf77b597ab5727e162309d4.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/player.gd-folding-f3e766a223e56b2d62acb89340e64980.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/player.tscn-editstate-c2c62cb8c73458cd122faf659769dc80.cfg">
[editor_states]

Anim={
"visible": false
}
2D={
"grid_offset": Vector2(0, 0),
"grid_snap_active": false,
"grid_step": Vector2(8, 8),
"grid_visibility": 1,
"ofs": Vector2(-1552.98, -1019.12),
"primary_grid_step": Vector2i(8, 8),
"show_group_gizmos": true,
"show_guides": true,
"show_helpers": false,
"show_lock_gizmos": true,
"show_origin": true,
"show_position_gizmos": true,
"show_rulers": true,
"show_transformation_gizmos": true,
"show_viewport": true,
"show_zoom_control": true,
"smart_snap_active": false,
"snap_guides": true,
"snap_node_anchors": true,
"snap_node_center": true,
"snap_node_parent": true,
"snap_node_sides": true,
"snap_other_nodes": true,
"snap_pixel": true,
"snap_relative": false,
"snap_rotation": false,
"snap_rotation_offset": 0.0,
"snap_rotation_step": 0.261799,
"snap_scale": false,
"snap_scale_step": 0.1,
"zoom": 0.125
}
3D={
"fov": 70.01,
"gizmos_status": {
"AudioListener3D": 0,
"AudioStreamPlayer3D": 0,
"CPUParticles3D": 0,
"CSGShape3D": 0,
"Camera3D": 0,
"CollisionObject3D": 0,
"CollisionPolygon3D": 0,
"CollisionShape3D": 0,
"Decal": 0,
"FogVolume": 0,
"GPUParticles3D": 0,
"GPUParticlesCollision3D": 0,
"Joint3D": 0,
"Light3D": 0,
"LightmapGI": 0,
"LightmapProbe": 0,
"Marker3D": 0,
"MeshInstance3DCustomAABB": 0,
"NavigationLink3D": 0,
"NavigationRegion3D": 0,
"OccluderInstance3D": 0,
"Path3D": 0,
"PhysicalBone3D": 0,
"RayCast3D": 0,
"ReflectionProbe": 0,
"ShapeCast3D": 0,
"Skeleton3D": 0,
"SoftBody3D": 0,
"SpringArm3D": 0,
"VehicleWheel3D": 0,
"VisibleOnScreenNotifier3D": 0,
"VoxelGI": 0
},
"local_coords": false,
"preview_sun_env": {
"environ_ao_enabled": false,
"environ_enabled": true,
"environ_energy": 1.0,
"environ_gi_enabled": false,
"environ_glow_enabled": true,
"environ_ground_color": Color(0.2, 0.169, 0.133, 1),
"environ_sky_color": Color(0.385, 0.454, 0.55, 1),
"environ_tonemap_enabled": true,
"sun_color": Color(1, 1, 1, 1),
"sun_enabled": true,
"sun_energy": 1.0,
"sun_max_distance": 100.0,
"sun_rotation": Vector2(-1.0472, 2.61799)
},
"rotate_snap": 15.0,
"scale_snap": 10.0,
"show_grid": true,
"show_origin": true,
"snap_enabled": false,
"translate_snap": 1.0,
"viewport_mode": 1,
"viewports": [{
"auto_orthogonal": false,
"auto_orthogonal_enabled": true,
"cinematic_preview": false,
"display_mode": 21,
"distance": 4.0,
"doppler": false,
"frame_time": false,
"gizmos": true,
"half_res": false,
"information": false,
"listener": true,
"lock_rotation": false,
"orthogonal": false,
"position": Vector3(0, 0, 0),
"use_environment": false,
"view_type": 0,
"x_rotation": 0.5,
"y_rotation": -0.5
}, {
"auto_orthogonal": false,
"auto_orthogonal_enabled": true,
"cinematic_preview": false,
"display_mode": 21,
"distance": 4.0,
"doppler": false,
"frame_time": false,
"gizmos": true,
"half_res": false,
"information": false,
"listener": false,
"lock_rotation": false,
"orthogonal": false,
"position": Vector3(0, 0, 0),
"use_environment": false,
"view_type": 0,
"x_rotation": 0.5,
"y_rotation": -0.5
}, {
"auto_orthogonal": false,
"auto_orthogonal_enabled": true,
"cinematic_preview": false,
"display_mode": 21,
"distance": 4.0,
"doppler": false,
"frame_time": false,
"gizmos": true,
"half_res": false,
"information": false,
"listener": false,
"lock_rotation": false,
"orthogonal": false,
"position": Vector3(0, 0, 0),
"use_environment": false,
"view_type": 0,
"x_rotation": 0.5,
"y_rotation": -0.5
}, {
"auto_orthogonal": false,
"auto_orthogonal_enabled": true,
"cinematic_preview": false,
"display_mode": 21,
"distance": 4.0,
"doppler": false,
"frame_time": false,
"gizmos": true,
"half_res": false,
"information": false,
"listener": false,
"lock_rotation": false,
"orthogonal": false,
"position": Vector3(0, 0, 0),
"use_environment": false,
"view_type": 0,
"x_rotation": 0.5,
"y_rotation": -0.5
}],
"zfar": 4000.01,
"znear": 0.05
}
selected_nodes=Array[NodePath]([])
</file>

<file path=".godot/editor/player.tscn-folding-c2c62cb8c73458cd122faf659769dc80.cfg">
[folding]

node_unfolds=[NodePath("."), PackedStringArray("Collision", "Linear")]
resource_unfolds=["res://scenes/player/player.tscn::CircleShape2D_1", PackedStringArray("Resource")]
nodes_folded=[]
</file>

<file path=".godot/editor/pop.mp3-67e17343cda83c66845025dcce55cb20.mp3str-folding-9bc5f4cf8ad755cc90b7ee014331c3a4.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/pop.mp3-8a0c1ee8b23ba0bce4af1df1b73a2c47.mp3str-folding-e15f8994f0fa46149533a1fdf0bc16a2.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/project_metadata.cfg">
[editor_metadata]

executable_path="/Applications/Godot.app/Contents/MacOS/Godot"

[recent_files]

scripts=["res://scripts/singletons/GameState.gd", "res://scripts/player/player.gd", "res://tasks/DevelopmentPlan.md"]
scenes=["res://scenes/player/player.tscn"]
</file>

<file path=".godot/editor/script_editor_cache.cfg">
[res://tasks/DevelopmentPlan.md]

state={
"bookmarks": PackedInt32Array(),
"breakpoints": PackedInt32Array(),
"column": 24,
"folded_lines": Array[int]([]),
"h_scroll_position": 0,
"row": 41,
"scroll_position": 38.0,
"selection": true,
"selection_from_column": 23,
"selection_from_line": 41,
"selection_to_column": 24,
"selection_to_line": 41,
"syntax_highlighter": "Plain Text"
}

[res://scripts/player/player.gd]

state={
"bookmarks": PackedInt32Array(),
"breakpoints": PackedInt32Array(),
"column": 0,
"folded_lines": Array[int]([]),
"h_scroll_position": 0,
"row": 0,
"scroll_position": 0.0,
"selection": false,
"syntax_highlighter": "GDScript"
}

[res://scripts/singletons/GameState.gd]

state={
"bookmarks": PackedInt32Array(),
"breakpoints": PackedInt32Array(),
"column": 0,
"folded_lines": Array[int]([]),
"h_scroll_position": 0,
"row": 0,
"scroll_position": 0.0,
"selection": false,
"syntax_highlighter": "GDScript"
}
</file>

<file path=".godot/editor/success.mp3-2f4cfc1e2ce208c30d0192cb1e366d1a.mp3str-folding-fb8faa49ddd5890251ea8d15ba9b3111.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/editor/success.mp3-8c2123d5a82507e48393b4843ef40866.mp3str-folding-c5c275bd1e1bdf5c4dcf5f6917521fc5.cfg">
[folding]

sections_unfolded=PackedStringArray()
</file>

<file path=".godot/imported/ball.png-b42bc1a78430fc3412eda843a2d529ba.md5">
source_md5="589e5402feb2283eda54799d19992166"
dest_md5="9d6747fe590124247dbd599adf5ce103"
</file>

<file path=".godot/imported/ball.png-b8e6aa06c746a4928b1493a1566800b7.md5">
source_md5="589e5402feb2283eda54799d19992166"
dest_md5="9d6747fe590124247dbd599adf5ce103"
</file>

<file path=".godot/imported/Balloon Escape Factory.mp3-54140b5b2b11b7904ee81e622b8af5f7.md5">
source_md5="769ae3b87f06767814d4e71ef332b99b"
dest_md5="26c26f8b01b50a280fcb2f5d0fa4b8f0"
</file>

<file path=".godot/imported/Balloon Escape Factory.mp3-a84b0e9981ac63b9aa18472c4c340af6.md5">
source_md5="769ae3b87f06767814d4e71ef332b99b"
dest_md5="13e1652b007510ed697578303d91fc4f"
</file>

<file path=".godot/imported/bg_layer1.png-448a8143e3892073d6b96852c0d29f68.md5">
source_md5="f2e059dd52fa2ba1eef76d7aed06606c"
dest_md5="50b65a22f846cd1052f95369ce678efc"
</file>

<file path=".godot/imported/bg_layer1.png-d7aad465b3d677b057046413bf620986.md5">
source_md5="f2e059dd52fa2ba1eef76d7aed06606c"
dest_md5="50b65a22f846cd1052f95369ce678efc"
</file>

<file path=".godot/imported/bounce.mp3-40b4ac2a57340ad0a4800cce652f4adb.md5">
source_md5="c90295041a3bb2f8e459d04696e80669"
dest_md5="0f4ac9deb20bef09cf38f5cd59980448"
</file>

<file path=".godot/imported/bounce.mp3-c83954d43e882cf41da4bb95039bb03d.md5">
source_md5="c90295041a3bb2f8e459d04696e80669"
dest_md5="2c3c8dc789d328fd567e6015d1c632c5"
</file>

<file path=".godot/imported/coins.mp3-7dc50d0b845a91d46fb5cdd74a20d161.md5">
source_md5="70583837de961117751be9cb15a4462d"
dest_md5="cb962ffe4c4b576c347b64d9d6b3e69b"
</file>

<file path=".godot/imported/coins.mp3-f6db493078653e3c3432ef7bfd892903.md5">
source_md5="70583837de961117751be9cb15a4462d"
dest_md5="abf03a5bb34185caa93df44f5bd34a62"
</file>

<file path=".godot/imported/gold_1.png-ce85689bdf1a2e894fb7bb02067050f8.md5">
source_md5="a9a63f7d2e4660e8f0671e3182974241"
dest_md5="6f5cbd1993021f8210cdf7eec31625b5"
</file>

<file path=".godot/imported/gold_1.png-db46b66b9e6ef0a985206ce30f386ed4.md5">
source_md5="a9a63f7d2e4660e8f0671e3182974241"
dest_md5="6f5cbd1993021f8210cdf7eec31625b5"
</file>

<file path=".godot/imported/gold_2.png-8ade76d86f08dbc818f88c105df709be.md5">
source_md5="5459782269248701e0763e87e5cb58f2"
dest_md5="9311929f93bdc4d1ef20846e0a7d3bfa"
</file>

<file path=".godot/imported/gold_2.png-ceeb5eec4d9a8f3664fa8cc38cccf4bf.md5">
source_md5="5459782269248701e0763e87e5cb58f2"
dest_md5="9311929f93bdc4d1ef20846e0a7d3bfa"
</file>

<file path=".godot/imported/gold_3.png-07ceaf45def4d2d47fac62b91b6517bd.md5">
source_md5="aa6be19fab8a02704eaccf810fabe347"
dest_md5="34da73840027a35585a297f2ab6435b6"
</file>

<file path=".godot/imported/gold_3.png-2a0ca9d63e62ff045778d59d9dc377b6.md5">
source_md5="aa6be19fab8a02704eaccf810fabe347"
dest_md5="34da73840027a35585a297f2ab6435b6"
</file>

<file path=".godot/imported/ground_stone_broken.png-031ff3db296cf9afe9884f044f68cea2.md5">
source_md5="18817ccd1aad965f1203130d29906aa3"
dest_md5="1c7312a44d039431ed2ba3843de9accf"
</file>

<file path=".godot/imported/ground_stone_broken.png-951b10430d8294a08834f774aad0677a.md5">
source_md5="18817ccd1aad965f1203130d29906aa3"
dest_md5="1c7312a44d039431ed2ba3843de9accf"
</file>

<file path=".godot/imported/ground_stone_small_broken.png-46a5bcba6bc2926e8e42011cd9cb8aed.md5">
source_md5="042f4d88eae9b9318931eb01d281c032"
dest_md5="26d50540e3194bc2ffc9fca12e0668ed"
</file>

<file path=".godot/imported/ground_stone_small_broken.png-cb7fc31b3ff9f21e979b6b81794fe6b7.md5">
source_md5="042f4d88eae9b9318931eb01d281c032"
dest_md5="26d50540e3194bc2ffc9fca12e0668ed"
</file>

<file path=".godot/imported/ground_stone_small.png-1e2024afc10899f6d1e3e5da3365e4af.md5">
source_md5="46260e86ca6d21cbe2da9351f889e61c"
dest_md5="aa2e12c5e7cb64961456bfaf04f5c3ad"
</file>

<file path=".godot/imported/ground_stone_small.png-4849dc2b09040fa5788ce9d24d033840.md5">
source_md5="46260e86ca6d21cbe2da9351f889e61c"
dest_md5="aa2e12c5e7cb64961456bfaf04f5c3ad"
</file>

<file path=".godot/imported/ground_stone.png-0bd443f60f21a15810f7368646956ffa.md5">
source_md5="16c9252750c6138e50cfd6b2b2b316ef"
dest_md5="1b7b7ebc87b4be0c782f8d1583036a73"
</file>

<file path=".godot/imported/ground_stone.png-6b1440ca0d40ac663187ab858a651c21.md5">
source_md5="16c9252750c6138e50cfd6b2b2b316ef"
dest_md5="1b7b7ebc87b4be0c782f8d1583036a73"
</file>

<file path=".godot/imported/ground_wood_broken.png-dd276242039b45259ccad59065be77d5.md5">
source_md5="e81fcac50b0b046235b097d159ed7d96"
dest_md5="466a31184e856bdb1d6a68811a51d7cc"
</file>

<file path=".godot/imported/ground_wood_broken.png-df96d7686bdd747217995967851dabb2.md5">
source_md5="e81fcac50b0b046235b097d159ed7d96"
dest_md5="466a31184e856bdb1d6a68811a51d7cc"
</file>

<file path=".godot/imported/ground_wood_small_broken.png-a3587c5b407e85fc3c7e2b68de2d7274.md5">
source_md5="d2dcafed90d6947b2ff12411235b8179"
dest_md5="04cb611d7a4143fe26e5a45922d9981d"
</file>

<file path=".godot/imported/ground_wood_small_broken.png-a3c0fbd05c9702f0c8ef67962b913ec0.md5">
source_md5="d2dcafed90d6947b2ff12411235b8179"
dest_md5="04cb611d7a4143fe26e5a45922d9981d"
</file>

<file path=".godot/imported/ground_wood_small.png-7ecffbe7ca5b3c5d7ccda9e262cbc169.md5">
source_md5="e3bca44652e958d7f232b65d8c675680"
dest_md5="e6319484625574e66d67c02f00ea4f13"
</file>

<file path=".godot/imported/ground_wood_small.png-bdbad7e757dd8c52068ca768c451bb41.md5">
source_md5="e3bca44652e958d7f232b65d8c675680"
dest_md5="e6319484625574e66d67c02f00ea4f13"
</file>

<file path=".godot/imported/ground_wood.png-a52d13af3cc19d314dd0d09e450484f2.md5">
source_md5="b3b217f1a5aaedb16067daf093d34d66"
dest_md5="348ff07d57b0a934ba595e12160cc578"
</file>

<file path=".godot/imported/ground_wood.png-f0b3d2229bc74c48d3c01145bf6f093f.md5">
source_md5="b3b217f1a5aaedb16067daf093d34d66"
dest_md5="348ff07d57b0a934ba595e12160cc578"
</file>

<file path=".godot/imported/jetpack_item.png-40a582ff252f95b4aa8ef6e65241ffa5.md5">
source_md5="d8339ec4e8c74d6d6eca9578fc8f60ea"
dest_md5="a983282747091a69ec97678f06ba355b"
</file>

<file path=".godot/imported/jetpack_item.png-f60f7b9d86b86072d4f6e05fe8211f10.md5">
source_md5="d8339ec4e8c74d6d6eca9578fc8f60ea"
dest_md5="a983282747091a69ec97678f06ba355b"
</file>

<file path=".godot/imported/jetpack.png-a07c4cb1b95f9ce3f872c85465ade680.md5">
source_md5="cc2cdce2107e4505b9ade8409aa51533"
dest_md5="2f01d329d66d4ed3c03226e70636f5e1"
</file>

<file path=".godot/imported/jetpack.png-b90b6e87e060ca5cd324a9f77391caac.md5">
source_md5="cc2cdce2107e4505b9ade8409aa51533"
dest_md5="2f01d329d66d4ed3c03226e70636f5e1"
</file>

<file path=".godot/imported/Kenney Future Narrow.ttf-453e2fa23c1cd4a37e88d1e6aae31b2a.md5">
source_md5="2d9994ffeb45bba6b4fbe2439e69f862"
dest_md5="c8d70131adcd2456b872c5674a5efca5"
</file>

<file path=".godot/imported/Kenney Future Narrow.ttf-ef7e34836d9e5dc059ca737da9380cb7.md5">
source_md5="2d9994ffeb45bba6b4fbe2439e69f862"
dest_md5="d11b96c53629b1359948fb6cdc8e0f12"
</file>

<file path=".godot/imported/Kenney Future.ttf-3e4bff56a5c053e0f32b5e9c961621bc.md5">
source_md5="aa105baf5908a03629b913df67e5e6a9"
dest_md5="5df78105835eb95f04fb76ef627417cc"
</file>

<file path=".godot/imported/Kenney Future.ttf-845b8d86f13614effd75cae8b9fe56b9.md5">
source_md5="aa105baf5908a03629b913df67e5e6a9"
dest_md5="a01d39aadeb96c40261b98dc8a090ff7"
</file>

<file path=".godot/imported/lives_coin_bronze.png-48dc32bdc49e21e82bb6f174160bbae0.md5">
source_md5="427e54ab24e1d4946e4616d975730e09"
dest_md5="176c9aac91a475d9f23bb890b03467bc"
</file>

<file path=".godot/imported/lives_coin_bronze.png-c491644430900a183d49ff9bcbd16664.md5">
source_md5="427e54ab24e1d4946e4616d975730e09"
dest_md5="176c9aac91a475d9f23bb890b03467bc"
</file>

<file path=".godot/imported/platformPack_tile004.png-2852e78ff4503106706ebe0cb367ee72.md5">
source_md5="525d87d8226d2cd0e7b57e6081cdbb2a"
dest_md5="b38dd74ccf1a4b9b67bdb71b4fecf6ef"
</file>

<file path=".godot/imported/platformPack_tile004.png-7fab26bba6cb2b1d4d9e3512bc743172.md5">
source_md5="525d87d8226d2cd0e7b57e6081cdbb2a"
dest_md5="b38dd74ccf1a4b9b67bdb71b4fecf6ef"
</file>

<file path=".godot/imported/platformPack_tile034.png-ca4f4ece287a50142c6225506b38c7e0.md5">
source_md5="46dfda4cb0b1ed47dd1f4dadc48d75cd"
dest_md5="fb3a918e1a75209a01c7c06790a593fb"
</file>

<file path=".godot/imported/platformPack_tile034.png-d97ff266769a529eba2b47dff49109d9.md5">
source_md5="46dfda4cb0b1ed47dd1f4dadc48d75cd"
dest_md5="fb3a918e1a75209a01c7c06790a593fb"
</file>

<file path=".godot/imported/pop.mp3-67e17343cda83c66845025dcce55cb20.md5">
source_md5="b87c79f1cb3d1b248fe1f16149c47d7f"
dest_md5="1fc0978c0ba8829ab958442777e745cb"
</file>

<file path=".godot/imported/pop.mp3-8a0c1ee8b23ba0bce4af1df1b73a2c47.md5">
source_md5="b87c79f1cb3d1b248fe1f16149c47d7f"
dest_md5="3e8aea0859d11acfed5c3f009cceb846"
</file>

<file path=".godot/imported/spike_bottom.png-7e81a852e91320387fd73ac54e59bb59.md5">
source_md5="4a1cc490238f5192676e6c74b755715d"
dest_md5="1a775301c8e17aba8c435d3a1dcc6e50"
</file>

<file path=".godot/imported/spike_bottom.png-d4a2d1ad0907cee71e5f3da55815a9e9.md5">
source_md5="4a1cc490238f5192676e6c74b755715d"
dest_md5="1a775301c8e17aba8c435d3a1dcc6e50"
</file>

<file path=".godot/imported/spike_top.png-bd6769f098435c26d87d62df69144db0.md5">
source_md5="aa212a2cf5155bff89eb4469c07c0d51"
dest_md5="876499d714f44231828cb7230d5d8280"
</file>

<file path=".godot/imported/spike_top.png-fddb7c9aab302afc8a9417c3c88e618b.md5">
source_md5="aa212a2cf5155bff89eb4469c07c0d51"
dest_md5="876499d714f44231828cb7230d5d8280"
</file>

<file path=".godot/imported/spikes_bottom.png-0a54744ef319b9879b095ea552cd3a17.md5">
source_md5="ce0474409a6380f77c0ca4f6d8fcbef1"
dest_md5="20ac2050c1bf56ffcb41259b7a5aadd3"
</file>

<file path=".godot/imported/spikes_bottom.png-dfa63a25199c2cb2532dcedfd88f6b3d.md5">
source_md5="ce0474409a6380f77c0ca4f6d8fcbef1"
dest_md5="20ac2050c1bf56ffcb41259b7a5aadd3"
</file>

<file path=".godot/imported/spikes_top.png-60600659598e52a36081d7f594544828.md5">
source_md5="24a1757932e57459ba3d91bd48d79049"
dest_md5="6d9e9136266d5cdc45cda62afd6ed9e5"
</file>

<file path=".godot/imported/spikes_top.png-964376e5763eee2d0812fdf4e21c3998.md5">
source_md5="24a1757932e57459ba3d91bd48d79049"
dest_md5="6d9e9136266d5cdc45cda62afd6ed9e5"
</file>

<file path=".godot/imported/spring_in.png-7fc5f83a8c532c37407fef680d2036b9.md5">
source_md5="0b33d1bf4c464c5b1e94ddbb19f6ad4f"
dest_md5="d75369ea21a8eef9000fa99caa6f4077"
</file>

<file path=".godot/imported/spring_in.png-98f4981fd80b3a227b4c3f8bf2a6a5f4.md5">
source_md5="0b33d1bf4c464c5b1e94ddbb19f6ad4f"
dest_md5="d75369ea21a8eef9000fa99caa6f4077"
</file>

<file path=".godot/imported/spring_out.png-10ccb538d5372629a0ba43253a98a552.md5">
source_md5="15316deb3b11efcec37897e2dac84aef"
dest_md5="c4ece1da95a7e4af79396128f960f965"
</file>

<file path=".godot/imported/spring_out.png-6c0d3ee6db38931f4d254dbd7db9d984.md5">
source_md5="15316deb3b11efcec37897e2dac84aef"
dest_md5="c4ece1da95a7e4af79396128f960f965"
</file>

<file path=".godot/imported/spring.png-617f1f030d57217fdc379e07d6cd255d.md5">
source_md5="bf0b2b257993ffe85086a35ca39872c8"
dest_md5="0892ddb7a302c0fb6cf3340d6e26df09"
</file>

<file path=".godot/imported/spring.png-7c80b20e3ee39a78bddbc31742b8c47e.md5">
source_md5="bf0b2b257993ffe85086a35ca39872c8"
dest_md5="0892ddb7a302c0fb6cf3340d6e26df09"
</file>

<file path=".godot/imported/success.mp3-2f4cfc1e2ce208c30d0192cb1e366d1a.md5">
source_md5="8c61fffdab3e94a70388f851cafe7ac0"
dest_md5="5184e0053c081a17ddcf29a55e9e378b"
</file>

<file path=".godot/imported/success.mp3-8c2123d5a82507e48393b4843ef40866.md5">
source_md5="8c61fffdab3e94a70388f851cafe7ac0"
dest_md5="0456267978a581c300eb230098c28c7d"
</file>

<file path=".godot/.gdignore">

</file>

<file path=".godot/global_script_class_cache.cfg">
list=Array[Dictionary]([{
"base": &"RigidBody2D",
"class": &"Player",
"icon": "",
"language": &"GDScript",
"path": "res://scripts/player/player.gd"
}])
</file>

<file path="assets/audio/Balloon Escape Factory.mp3.import">
[remap]

importer="mp3"
type="AudioStreamMP3"
uid="uid://do6c1xwbq1bd7"
path="res://.godot/imported/Balloon Escape Factory.mp3-a84b0e9981ac63b9aa18472c4c340af6.mp3str"

[deps]

source_file="res://assets/audio/Balloon Escape Factory.mp3"
dest_files=["res://.godot/imported/Balloon Escape Factory.mp3-a84b0e9981ac63b9aa18472c4c340af6.mp3str"]

[params]

loop=false
loop_offset=0
bpm=0
beat_count=0
bar_beats=4
</file>

<file path="assets/audio/bounce.mp3.import">
[remap]

importer="mp3"
type="AudioStreamMP3"
uid="uid://d20s8e58nykrk"
path="res://.godot/imported/bounce.mp3-40b4ac2a57340ad0a4800cce652f4adb.mp3str"

[deps]

source_file="res://assets/audio/bounce.mp3"
dest_files=["res://.godot/imported/bounce.mp3-40b4ac2a57340ad0a4800cce652f4adb.mp3str"]

[params]

loop=false
loop_offset=0
bpm=0
beat_count=0
bar_beats=4
</file>

<file path="assets/audio/coins.mp3.import">
[remap]

importer="mp3"
type="AudioStreamMP3"
uid="uid://dktyjihn5fyne"
path="res://.godot/imported/coins.mp3-f6db493078653e3c3432ef7bfd892903.mp3str"

[deps]

source_file="res://assets/audio/coins.mp3"
dest_files=["res://.godot/imported/coins.mp3-f6db493078653e3c3432ef7bfd892903.mp3str"]

[params]

loop=false
loop_offset=0
bpm=0
beat_count=0
bar_beats=4
</file>

<file path="assets/audio/pop.mp3.import">
[remap]

importer="mp3"
type="AudioStreamMP3"
uid="uid://4lmuxjo3f1pj"
path="res://.godot/imported/pop.mp3-67e17343cda83c66845025dcce55cb20.mp3str"

[deps]

source_file="res://assets/audio/pop.mp3"
dest_files=["res://.godot/imported/pop.mp3-67e17343cda83c66845025dcce55cb20.mp3str"]

[params]

loop=false
loop_offset=0
bpm=0
beat_count=0
bar_beats=4
</file>

<file path="assets/audio/success.mp3.import">
[remap]

importer="mp3"
type="AudioStreamMP3"
uid="uid://bk5pyqdoc2gvr"
path="res://.godot/imported/success.mp3-8c2123d5a82507e48393b4843ef40866.mp3str"

[deps]

source_file="res://assets/audio/success.mp3"
dest_files=["res://.godot/imported/success.mp3-8c2123d5a82507e48393b4843ef40866.mp3str"]

[params]

loop=false
loop_offset=0
bpm=0
beat_count=0
bar_beats=4
</file>

<file path="BopAssets/SFX/Balloon Escape Factory.mp3.import">
[remap]

importer="mp3"
type="AudioStreamMP3"
uid="uid://dr5vlhmfe8y7b"
path="res://.godot/imported/Balloon Escape Factory.mp3-54140b5b2b11b7904ee81e622b8af5f7.mp3str"

[deps]

source_file="res://BopAssets/SFX/Balloon Escape Factory.mp3"
dest_files=["res://.godot/imported/Balloon Escape Factory.mp3-54140b5b2b11b7904ee81e622b8af5f7.mp3str"]

[params]

loop=false
loop_offset=0
bpm=0
beat_count=0
bar_beats=4
</file>

<file path="BopAssets/SFX/bounce.mp3.import">
[remap]

importer="mp3"
type="AudioStreamMP3"
uid="uid://bvkcchsl4ayo0"
path="res://.godot/imported/bounce.mp3-c83954d43e882cf41da4bb95039bb03d.mp3str"

[deps]

source_file="res://BopAssets/SFX/bounce.mp3"
dest_files=["res://.godot/imported/bounce.mp3-c83954d43e882cf41da4bb95039bb03d.mp3str"]

[params]

loop=false
loop_offset=0
bpm=0
beat_count=0
bar_beats=4
</file>

<file path="BopAssets/SFX/coins.mp3.import">
[remap]

importer="mp3"
type="AudioStreamMP3"
uid="uid://b8fls3reopyf1"
path="res://.godot/imported/coins.mp3-7dc50d0b845a91d46fb5cdd74a20d161.mp3str"

[deps]

source_file="res://BopAssets/SFX/coins.mp3"
dest_files=["res://.godot/imported/coins.mp3-7dc50d0b845a91d46fb5cdd74a20d161.mp3str"]

[params]

loop=false
loop_offset=0
bpm=0
beat_count=0
bar_beats=4
</file>

<file path="BopAssets/SFX/pop.mp3.import">
[remap]

importer="mp3"
type="AudioStreamMP3"
uid="uid://cdgnxiofmt0eq"
path="res://.godot/imported/pop.mp3-8a0c1ee8b23ba0bce4af1df1b73a2c47.mp3str"

[deps]

source_file="res://BopAssets/SFX/pop.mp3"
dest_files=["res://.godot/imported/pop.mp3-8a0c1ee8b23ba0bce4af1df1b73a2c47.mp3str"]

[params]

loop=false
loop_offset=0
bpm=0
beat_count=0
bar_beats=4
</file>

<file path="BopAssets/SFX/success.mp3.import">
[remap]

importer="mp3"
type="AudioStreamMP3"
uid="uid://bj1dm7raxteqd"
path="res://.godot/imported/success.mp3-2f4cfc1e2ce208c30d0192cb1e366d1a.mp3str"

[deps]

source_file="res://BopAssets/SFX/success.mp3"
dest_files=["res://.godot/imported/success.mp3-2f4cfc1e2ce208c30d0192cb1e366d1a.mp3str"]

[params]

loop=false
loop_offset=0
bpm=0
beat_count=0
bar_beats=4
</file>

<file path="scenes/levels/mvp_test.tscn">
[gd_scene load_steps=7 format=3]

[ext_resource type="PackedScene" path="res://scenes/player/player.tscn" id="1_player"]
[ext_resource type="Texture2D" path="res://assets/sprites/environment/ground_stone.png" id="2_ground"]
[ext_resource type="Script" path="res://scripts/player/player.gd" id="3_hhdod"]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_floor"]
size = Vector2(1920, 100)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_ceiling"]
size = Vector2(1920, 100)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_walls"]
size = Vector2(100, 1080)

[node name="MVPTestLevel" type="Node2D"]

[node name="Environment" type="Node2D" parent="."]

[node name="Floor" type="StaticBody2D" parent="Environment"]
position = Vector2(960, 1030)
collision_mask = 0

[node name="CollisionShape2D" type="CollisionShape2D" parent="Environment/Floor"]
shape = SubResource("RectangleShape2D_floor")

[node name="Sprite2D" type="Sprite2D" parent="Environment/Floor"]
modulate = Color(1, 0.5, 0.5, 1)
scale = Vector2(30, 1.5)
texture = ExtResource("2_ground")

[node name="Ceiling" type="StaticBody2D" parent="Environment"]
position = Vector2(960, 50)
collision_mask = 0

[node name="CollisionShape2D" type="CollisionShape2D" parent="Environment/Ceiling"]
shape = SubResource("RectangleShape2D_ceiling")

[node name="Sprite2D" type="Sprite2D" parent="Environment/Ceiling"]
modulate = Color(1, 0.5, 0.5, 1)
scale = Vector2(30, 1.5)
texture = ExtResource("2_ground")

[node name="LeftWall" type="StaticBody2D" parent="Environment"]
position = Vector2(50, 540)
collision_mask = 0

[node name="CollisionShape2D" type="CollisionShape2D" parent="Environment/LeftWall"]
shape = SubResource("RectangleShape2D_walls")

[node name="Sprite2D" type="Sprite2D" parent="Environment/LeftWall"]
modulate = Color(1, 0.5, 0.5, 1)
scale = Vector2(1.5, 17)
texture = ExtResource("2_ground")

[node name="RightWall" type="StaticBody2D" parent="Environment"]
position = Vector2(1870, 540)
collision_mask = 0

[node name="CollisionShape2D" type="CollisionShape2D" parent="Environment/RightWall"]
shape = SubResource("RectangleShape2D_walls")

[node name="Sprite2D" type="Sprite2D" parent="Environment/RightWall"]
modulate = Color(1, 0.5, 0.5, 1)
scale = Vector2(1.5, 17)
texture = ExtResource("2_ground")

[node name="Player" type="RigidBody2D" parent="." instance=ExtResource("1_player")]
position = Vector2(960, 800)
collision_layer = 2
collision_mask = 29
linear_damp = 0.5
script = ExtResource("3_hhdod")
player_texture = null
bounce_sound = null
pop_sound = null
horizontal_force = 1000.0
max_horizontal_speed = 400.0
bounce_value = 0.99
friction_value = 0.1
</file>

<file path="scenes/player/player.tscn">
[gd_scene load_steps=4 format=3 uid="uid://c1fnn1l64pxpx"]

[ext_resource type="Texture2D" uid="uid://dpekgc4qppjd1" path="res://assets/sprites/player/ball.png" id="1_mhtu1"]
[ext_resource type="Script" path="res://scripts/player/player.gd" id="2_player"]

[sub_resource type="CircleShape2D" id="CircleShape2D_1"]
radius = 32.0

[node name="root" type="RigidBody2D"]
collision_layer = 2
collision_mask = 29
script = ExtResource("2_player")

[node name="Sprite2D" type="Sprite2D" parent="."]
texture = ExtResource("1_mhtu1")

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
shape = SubResource("CircleShape2D_1")

[node name="AudioStreamPlayer" type="AudioStreamPlayer" parent="."]
</file>

<file path="scripts/player/player.gd">
"""
Player Controller for Bop Game
Manages a bouncing ball with horizontal movement control.
Includes basic multiplayer hooks for future expansion.
"""
class_name Player
extends RigidBody2D

# Export variables for visual assets (following best practices)
@export var player_texture: Texture2D
@export var bounce_sound: AudioStream
@export var pop_sound: AudioStream

# Movement parameters
@export var horizontal_force: float = 1000.0
@export var max_horizontal_speed: float = 400.0

# Physics material properties (set via script for better control)
@export var bounce_value: float = 0.99
@export var friction_value: float = 0.1

# References to child nodes
@onready var sprite: Sprite2D = $Sprite2D
@onready var collision_shape: CollisionShape2D = $CollisionShape2D
@onready var audio_player: AudioStreamPlayer = $AudioStreamPlayer

# Multiplayer and state variables
var is_alive: bool = true
var last_collision_time: float = 0.0
var collision_cooldown: float = 0.1  # Prevent sound spam

func _ready() -> void:
	"""Initialize the player with proper settings."""
	
	print("Player: Initializing...")
	
	# Set up physics properties
	mass = 1.0
	gravity_scale = 1.0
	linear_damp = 0.5  # For smooth horizontal movement
	
	# Create and assign physics material
	var physics_material = PhysicsMaterial.new()
	physics_material.bounce = bounce_value
	physics_material.friction = friction_value
	physics_material_override = physics_material
	
	# Set up sprite texture if provided
	if player_texture and sprite:
		sprite.texture = player_texture
		print("Player: Texture assigned to sprite")
	
	# Connect collision signals
	body_entered.connect(_on_body_entered)
	
	print("Player: Initialization complete")

func _physics_process(delta: float) -> void:
	"""Handle physics processing including movement input."""
	# Only process input if this is the authority in multiplayer (or single-player)
	if not is_multiplayer_authority():
		return
	
	# Get horizontal input using Input.get_axis for smooth movement
	var input_dir: float = Input.get_axis("move_left", "move_right")
	
	# Apply horizontal force if input detected
	if input_dir != 0.0:
		# Check if we're below max speed before applying more force
		if abs(linear_velocity.x) < max_horizontal_speed:
			var force_vector = Vector2(input_dir * horizontal_force * delta, 0.0)
			apply_central_force(force_vector)
			
		# Clamp velocity to prevent exceeding max speed
		if abs(linear_velocity.x) > max_horizontal_speed:
			linear_velocity.x = sign(linear_velocity.x) * max_horizontal_speed

func _integrate_forces(state: PhysicsDirectBodyState2D) -> void:
	"""Handle collision detection and sound effects."""
	# Check for collisions
	for i in range(state.get_contact_count()):
		var contact = state.get_contact_local_normal(i)
		var collider = state.get_contact_collider_object(i)
		
		# Detect floor/ceiling bounces (vertical collisions)
		if abs(contact.y) > 0.7:  # Mostly vertical collision
			_handle_bounce_collision()
		
		# Handle hazard collisions
		if collider and collider.is_in_group("hazards"):
			_handle_hazard_collision()

func _handle_bounce_collision() -> void:
	"""Handle normal bouncing collisions with sound effects."""
	var current_time = Time.get_time_dict_from_system()
	var time_stamp = current_time.hour * 3600 + current_time.minute * 60 + current_time.second + current_time.millisecond / 1000.0
	
	# Prevent sound spam with cooldown
	if time_stamp - last_collision_time > collision_cooldown:
		last_collision_time = time_stamp
		
		# Play bounce sound through SoundManager
		if has_node("/root/SoundManager"):
			get_node("/root/SoundManager").play_sfx("bounce")
			print("Player: Bounce collision detected, playing sound")

func _handle_hazard_collision() -> void:
	"""Handle collision with hazards (spikes, etc.)."""
	if not is_alive:
		return
		
	print("Player: Hit hazard! Triggering death sequence")
	is_alive = false
	
	# Play pop sound
	if has_node("/root/SoundManager"):
		get_node("/root/SoundManager").play_sfx("pop")
	
	# Emit signal to GameState for life management
	if has_node("/root/GameState"):
		get_node("/root/GameState").emit_signal("player_died")
	
	# Could add visual effects here (death animation, particle effects)

func _on_body_entered(body: Node) -> void:
	"""Handle Area2D body entered signals (for collectibles, power-ups)."""
	print("Player: Body entered detection: ", body.name)
	
	# Handle collectibles
	if body.is_in_group("collectibles"):
		print("Player: Collected item: ", body.name)
		# Let the collectible handle itself and notify GameState
	
	# Handle power-ups
	if body.is_in_group("powerups"):
		print("Player: Power-up collected: ", body.name)
		# Let the power-up handle itself and apply effects

# Multiplayer support methods
func set_player_id(id: int) -> void:
	"""Set the multiplayer player ID."""
	set_multiplayer_authority(id)
	print("Player: Set multiplayer authority to player ", id)

func get_position_data() -> Dictionary:
	"""Get position data for multiplayer synchronization."""
	return {
		"position": global_position,
		"velocity": linear_velocity,
		"angular_velocity": angular_velocity
	}

func apply_position_data(data: Dictionary) -> void:
	"""Apply position data from multiplayer synchronization."""
	global_position = data.position
	linear_velocity = data.velocity
	angular_velocity = data.angular_velocity
</file>

<file path="scripts/singletons/GameState.gd">
"""
GameState Singleton
Manages global game state including lives, score, level progression, and player events.
Acts as an Event Bus for game-wide communication.
"""
extends Node

# Game state variables
var player_lives: int = 3
var current_score: int = 0
var current_level: int = 1
var game_mode: String = "single"  # "single" or "multi"
var hoops_collected: int = 0

# Player state
var players_alive: Array[bool] = [true, true]  # For multiplayer support
var is_game_over: bool = false
var is_level_complete: bool = false

# Signals for event bus communication
signal player_died
signal life_lost(remaining_lives: int)
signal game_over
signal level_complete
signal score_changed(new_score: int)
signal hoop_collected(value: int)
signal powerup_activated(type: String)

func _ready() -> void:
	"""Initialize GameState singleton."""
	print("GameState: Singleton initialized")
	
	# Connect internal signals
	player_died.connect(_on_player_died)
	hoop_collected.connect(_on_hoop_collected)
	
	# Set initial lives based on game mode
	_set_initial_lives()

func _set_initial_lives() -> void:
	"""Set initial lives based on game mode."""
	match game_mode:
		"single":
			player_lives = 3
		"multi":
			player_lives = 5
		_:
			player_lives = 3
	
	print("GameState: Lives set to ", player_lives, " for ", game_mode, " player mode")

func set_game_mode(mode: String) -> void:
	"""Set the game mode (single or multi player)."""
	game_mode = mode
	_set_initial_lives()
	print("GameState: Game mode set to ", mode)

func _on_player_died() -> void:
	"""Handle player death."""
	print("GameState: Player died, processing life loss")
	
	if player_lives > 1:
		player_lives -= 1
		life_lost.emit(player_lives)
		print("GameState: Life lost, remaining lives: ", player_lives)
		
		# Restart level or reset player position
		_restart_level()
	else:
		player_lives = 0
		is_game_over = true
		game_over.emit()
		print("GameState: Game Over!")

func _on_hoop_collected(value: int) -> void:
	"""Handle hoop/collectible collection."""
	hoops_collected += 1
	current_score += value
	score_changed.emit(current_score)
	print("GameState: Hoop collected! Total: ", hoops_collected, " Score: ", current_score)

func add_score(points: int) -> void:
	"""Add points to the current score."""
	current_score += points
	score_changed.emit(current_score)
	print("GameState: Score increased by ", points, " Total: ", current_score)

func complete_level() -> void:
	"""Mark the current level as complete."""
	is_level_complete = true
	level_complete.emit()
	print("GameState: Level ", current_level, " complete!")

func next_level() -> void:
	"""Progress to the next level."""
	current_level += 1
	hoops_collected = 0
	is_level_complete = false
	print("GameState: Advanced to level ", current_level)

func reset_game() -> void:
	"""Reset game state for new game."""
	current_score = 0
	current_level = 1
	hoops_collected = 0
	is_game_over = false
	is_level_complete = false
	players_alive = [true, true]
	_set_initial_lives()
	print("GameState: Game reset")

func _restart_level() -> void:
	"""Restart the current level."""
	print("GameState: Restarting level...")
	# This will be implemented to reload the current scene
	# For now, just reset player state
	is_level_complete = false

func get_game_data() -> Dictionary:
	"""Get current game state data."""
	return {
		"lives": player_lives,
		"score": current_score,
		"level": current_level,
		"hoops": hoops_collected,
		"mode": game_mode,
		"game_over": is_game_over,
		"level_complete": is_level_complete
	}
</file>

<file path="scripts/singletons/SoundManager.gd">
"""
SoundManager Singleton
Handles all audio playback including sound effects and background music.
Provides a centralized system for managing game audio.
"""
extends Node

# Audio player references
@onready var music_player: AudioStreamPlayer = $MusicPlayer
@onready var sfx_player: AudioStreamPlayer = $SfxPlayer

# Preloaded sound effects library
var sfx_library: Dictionary = {}

# Volume settings
var master_volume: float = 1.0
var music_volume: float = 0.7
var sfx_volume: float = 0.8

func _ready() -> void:
	"""Initialize the SoundManager singleton."""
	print("SoundManager: Initializing...")
	
	# Set up audio players
	if music_player:
		music_player.volume_db = linear_to_db(music_volume * master_volume)
		print("SoundManager: Music player configured")
	
	if sfx_player:
		sfx_player.volume_db = linear_to_db(sfx_volume * master_volume)
		print("SoundManager: SFX player configured")
	
	# Load sound effects into library
	_load_sfx_library()
	
	print("SoundManager: Initialization complete")

func _load_sfx_library() -> void:
	"""Preload all sound effects into the library."""
	print("SoundManager: Loading SFX library...")
	
	# Load sound effects from the assets/audio/ directory
	var sfx_paths = {
		"bounce": "res://assets/audio/bounce.mp3",
		"pop": "res://assets/audio/pop.mp3",
		"coins": "res://assets/audio/coins.mp3",
		"success": "res://assets/audio/success.mp3"
	}
	
	for sfx_name in sfx_paths:
		var path = sfx_paths[sfx_name]
		if ResourceLoader.exists(path):
			var audio_stream = load(path) as AudioStream
			if audio_stream:
				sfx_library[sfx_name] = audio_stream
				print("SoundManager: Loaded SFX - ", sfx_name)
			else:
				print("SoundManager: Failed to load SFX - ", sfx_name)
		else:
			print("SoundManager: SFX file not found - ", path)
	
	print("SoundManager: SFX library loaded with ", sfx_library.size(), " sounds")

func play_sfx(sfx_name: String) -> void:
	"""Play a sound effect by name."""
	if not sfx_library.has(sfx_name):
		print("SoundManager: SFX not found - ", sfx_name)
		return
	
	if not sfx_player:
		print("SoundManager: SFX player not available")
		return
	
	print("SoundManager: Playing SFX - ", sfx_name)
	sfx_player.stream = sfx_library[sfx_name]
	sfx_player.play()

func play_music(music_stream: AudioStream, loop: bool = true) -> void:
	"""Play background music."""
	if not music_player:
		print("SoundManager: Music player not available")
		return
	
	print("SoundManager: Playing music")
	music_player.stream = music_stream
	music_player.stream.loop = loop
	music_player.play()

func stop_music() -> void:
	"""Stop background music."""
	if music_player:
		music_player.stop()
		print("SoundManager: Music stopped")

func set_master_volume(volume: float) -> void:
	"""Set the master volume (0.0 to 1.0)."""
	master_volume = clamp(volume, 0.0, 1.0)
	_update_volumes()
	print("SoundManager: Master volume set to ", master_volume)

func set_music_volume(volume: float) -> void:
	"""Set the music volume (0.0 to 1.0)."""
	music_volume = clamp(volume, 0.0, 1.0)
	_update_volumes()
	print("SoundManager: Music volume set to ", music_volume)

func set_sfx_volume(volume: float) -> void:
	"""Set the SFX volume (0.0 to 1.0)."""
	sfx_volume = clamp(volume, 0.0, 1.0)
	_update_volumes()
	print("SoundManager: SFX volume set to ", sfx_volume)

func _update_volumes() -> void:
	"""Update audio player volumes based on current settings."""
	if music_player:
		music_player.volume_db = linear_to_db(music_volume * master_volume)
	
	if sfx_player:
		sfx_player.volume_db = linear_to_db(sfx_volume * master_volume)

func get_audio_data() -> Dictionary:
	"""Get current audio settings."""
	return {
		"master_volume": master_volume,
		"music_volume": music_volume,
		"sfx_volume": sfx_volume,
		"sfx_count": sfx_library.size()
	}
</file>

<file path="scripts/singletons/SoundManager.tscn">
[gd_scene load_steps=2 format=3 uid="uid://bjxb5k3rq67yd"]

[ext_resource type="Script" path="res://scripts/singletons/SoundManager.gd" id="1_8k3v4"]

[node name="SoundManager" type="Node"]
script = ExtResource("1_8k3v4")

[node name="MusicPlayer" type="AudioStreamPlayer" parent="."]

[node name="SfxPlayer" type="AudioStreamPlayer" parent="."]
</file>

<file path="tasks/DevelopmentPlan.md">
"# Bop Game Development Plan

This document outlines a phased, incremental development plan for building the game 'Bop' in Godot 4.3. The plan focuses on starting with a Minimum Viable Product (MVP) as described in GameplayDesign.md, then adding features like menus, sounds, and full level elements. Each phase includes tasks, sub-tasks, and testing steps to ensure functionality is verifiable at every stage.

The plan adheres to the rules in physics.md, SFX.md, style.md, and multiplayer.md (noting that multiplayer is deferred until later phases, but with basic hooks added early for ease of integration). We prioritize single-player playability first, using autoloads like SoundManager and GameState, physics layers, and best practices like export variables and signals. Assets will be used from the assets/sprites/ folder as specified. Latency mitigation strategies (client-side prediction, server reconciliation, interpolation) from latency.md will be incorporated into multiplayer phases for smooth gameplay.

## [ ] Phase 1: Project Setup and MVP - Basic Bouncing Ball
**Goal:** Set up the Godot project with correct physics and get a ball bouncing automatically in a simple, non-scrolling scene with basic horizontal control. Include basic multiplayer hooks in player controls.


- [x] **Sub-task 1.1: Configure Project Settings**
  - [x] Set default gravity to 980 (or adjust to 1200 for tighter feel) in Project Settings > Physics > 2D.
  - [x] Set default linear damp to 0.
  - [x] Define physics layers: world, player, hazards, collectibles, phasewall.
  - [x] Add input actions for move_left and move_right if not already present (keyboard only).

- [x] **Sub-task 1.2: Create Player Scene (player.tscn in scenes/player/)**
  - [x] Root: RigidBody2D (Player node).
  - [x] Children: Sprite2D with ball.png texture from assets/sprites/player/ (use @export for texture).
  - [x] CollisionShape2D with CircleShape2D for hitbox.
  - [x] Assign PhysicsMaterial with bounce=0.99, friction=0.1.
  - [x] Set mass=1, gravity_scale=1.0, linear_damping=0.5 for smooth horizontal movement.
  - [x] Script: player.gd with _physics_process for horizontal input (Input.get_axis('move_left', 'move_right')) and apply force/velocity. Include basic multiplayer hook: Use is_multiplayer_authority() to process input only for the controlling player.

- [x] **Sub-task 1.3: Create MVP Test Scene (mvp_test.tscn in scenes/levels/)**
  - [x] Add TileMapLayer for simple floor and ceiling (use ground_stone.png from assets/sprites/environment/, modulate to red).
  - [x] Instance Player at starting position.
  - [x] Add StaticBody2D for walls/floor/ceiling with collision shapes.
  - [x] No camera following for non-scrolling MVP.

- [ ] **Sub-task 1.4: Testing**
  - [ ] Run the scene: Ball should bounce automatically between floor and ceiling.
  - [ ] Test horizontal movement: Smooth acceleration/deceleration with left/right keys.
  - [ ] Verify: No falling through floor, consistent bounce rhythm. Multiplayer hook doesn't affect single-player.

## [ ] Phase 2: Add Sound Effects to MVP
**Goal:** Integrate sound for bouncing and basic events, using SoundManager.


- [ ] **Sub-task 2.1: Set Up SoundManager (if not already)**
  - [ ] Create SoundManager.tscn in scripts/singletons/ with AudioStreamPlayer nodes for MusicPlayer and SfxPlayer.
  - [ ] Script: SoundManager.gd with sfx_library (preload bounce.mp3, pop.mp3, etc.).
  - [ ] Add as autoload in Project Settings.

- [ ] **Sub-task 2.2: Add Bounce Sound to Player**
  - [ ] In player.gd, detect collisions (use _integrate_forces or body_entered signal).
  - [ ] Call SoundManager.play_sfx('bounce') on floor/ceiling collision.

- [ ] **Sub-task 2.3: Testing**
  - [ ] Run MVP scene: Hear 'bop' sound on each bounce.
  - [ ] Verify: Sound plays correctly without overlap or errors.

## [ ] Phase 3: Main Menu and Loading Screen
**Goal:** Create menu for player selection and a loading/title screen before levels.


- [ ] **Sub-task 3.1: Create Main Menu Scene (main_menu.tscn in scenes/main_menu/)**
  - [ ] Use Control nodes for UI.
  - [ ] Add buttons for '1 Player' and '2 Player'.
  - [ ] Script: Handle button presses to set game mode (use GameState autoload to store mode).
  - [ ] Set as main scene in project.godot.

- [ ] **Sub-task 3.2: Create Loading Screen (loading_screen.tscn in scenes/ui/)**
  - [ ] Simple scene with 'LEVEL 1' label and lives display (use GameState for lives).
  - [ ] Timer to auto-transition to level after a few seconds.
  - [ ] From menu, change_scene to loading_screen, then to level.

- [ ] **Sub-task 3.3: Integrate with MVP**
  - [ ] From menu, load mvp_test.tscn after loading screen.

- [ ] **Sub-task 3.4: Testing**
  - [ ] Run game: Menu appears, select mode, see loading screen, then MVP scene.
  - [ ] Verify: Correct lives shown (3 for single, 5 for multi).

## [ ] Phase 4: Flesh Out Full Level 1
**Goal:** Expand to full scrolling level with hazards, power-ups, phase wall, coins, and goal.


- [ ] **Sub-task 4.1: Create Full Level Scene (level_1.tscn in scenes/levels/)**
  - [ ] Use TileMapLayer for extended level layout (safe zone, obstacles).
  - [ ] Add Camera2D as child of Player for following (now enabling scrolling).
  - [ ] Place static spikes (StaticBody2D with spike_bottom.png from assets/sprites/hazards/, hazards layer).

- [ ] **Sub-task 4.2: Add Hazards and Pop Effect**
  - [ ] Create Spike.tscn in scenes/hazards/ with collision detection.
  - [ ] On collision with player (use groups 'hazards'), trigger pop: Play 'pop' sound, show 'Pop!' label, deduct life via GameState, restart level.

- [ ] **Sub-task 4.3: Add Power-Ups and Collectibles**
  - [ ] Create PowerUp.tscn (Area2D) with jetpack.png from assets/sprites/collectibles_and_powerups/, signal on body_entered to apply effect (change gravity_scale).
  - [ ] Create Coin.tscn with animated gold sprites from assets/sprites/collectibles_and_powerups/, collect on overlap, update score in GameState.

- [ ] **Sub-task 4.4: Implement Phase Wall and Secret Area**
  - [ ] Use special tile for phase wall (platformPack_tile034.png from assets/sprites/environment/, phasewall layer).
  - [ ] Script to detect prolonged right-key press against it, teleport player to secret area (offset position in same scene).
  - [ ] Place coin in secret, teleport back on exit.

- [ ] **Sub-task 4.5: Level Completion**
  - [ ] Add goal Area2D (net, using appropriate asset), on enter emit signal to GameState, transition to 'Level Clear' screen showing hoops collected.
  - [ ] Create level_clear.tscn in scenes/ui/ for the clear screen.

- [ ] **Sub-task 4.6: Testing**
  - [ ] Run full level: Navigate sections, collect items, enter secret, avoid hazards, reach goal, see Level Clear screen.
  - [ ] Verify all physics, sounds, and transitions work.

## [ ] Phase 5: Polish and Multiplayer Hooks
**Goal:** Add HUD, power-up timer, and basic multiplayer setup with latency mitigation.

### [ ] Tasks:
- [ ] **Sub-task 5.1: Add HUD**
  - [ ] CanvasLayer in level with lives, hoops, power-up timer.

- [ ] **Sub-task 5.2: Full Power-Ups**
  - [ ] Implement Slow Down (adjust bounce freq), Speed Up, Sink/Float.

- [ ] **Sub-task 5.3: Multiplayer Basics**
  - [ ] If selected in menu, use MultiplayerSpawner for second player.
  - [ ] Sync positions with MultiplayerSynchronizer, handle shared lives.
  - [ ] Implement client-side prediction: In player.gd _physics_process, apply immediate movement for authority player and submit input via RPC.
  - [ ] Add server reconciliation: Compare predicted vs. authoritative position and correct if needed.
  - [ ] Use interpolation via MultiplayerSynchronizer for non-authority players.

- [ ] **Sub-task 5.4: Testing**
  - [ ] Test single and multi-player modes, ensure sync, no desyncs, and smooth movement despite simulated latency.

## Next Phases
- Phase 6: Additional Levels and Power-Ups
- Phase 7: Full Multiplayer Implementation (following multiplayer.mdc, and latency.md expanding on latency mitigation)
- Phase 8: Optimization, Bug Fixes, and Release

This plan ensures incremental builds with testing at each phase. We'll implement step-by-step using Godot tools."
</file>

<file path="_docs/GameplayDesign.md">
# Project Name
Bop

## Project Description
Bop is a 2D, rhythm-based platformer where the player controls the horizontal movement of a constantly bouncing ball. The objective is to navigate through a series of levels filled with obstacles and challenges without getting "popped." The game is designed for both single-player and a cooperative two-player mode, with a focus on skill, timing, and momentum.

## Target Audience
- Casual gamers looking for a simple "pick up and play" experience.
- Fans of skill-based, high-difficulty platformers (e.g., Geometry Dash, Super Meat Boy, Flappy Bird).
- Players who enjoy cooperative multiplayer challenges.

## Desired Features

### Core Gameplay Mechanics
- [X] **Player Control:** The player controls the ball's horizontal movement using left and right keys, with slight acceleration and deceleration.
- [X] **Automatic Bouncing:** The ball bounces automatically between the floor and ceiling at a steady, metronomic pace.
- [X] **Level Progression:** Players progress horizontally from a start point to an end point.
- [X] **Player Objective:** Collect optional golden hoops (3 per level) for a perfect score. The level can be completed without them.
- [X] **Lives System:**
    - [X] Single Player: 3 lives. Restart level on game over.
    - [X] Multiplayer: 5 shared lives. Restart level on game over.
- [X] **Secret Area Entry:** The player can hold the 'Right' key against specific, visually marked walls to phase into a hidden room.

### Player Character (The Ball)
- [X] **State:** Can be burst/destroyed by hazards.
- [X] **Physics & Interaction:**
    - [X] Hitbox is a perfect circle.
    - [X] Bounces off regular (non-hazardous) vertical walls.
    - [X] A squash-and-stretch animation occurs when hitting a surface.
    - [X] The ball disappears and the word "Pop!" appears when the ball touches a hazard.
    - [X] The ball changes color for the duration of an active power-up.

### Obstacles & Hazards
- [X] **Static Spikes:** Placed on the floor or ceiling.
- [X] **Moving Hazards:**
    - [X] Vertically moving knife/crusher.
    - [X] Rotating blade.

### Power-ups
- [X] **Slow Down:** The ball's vertical bounce frequency decreases for a limited time.
- [X] **Speed Up:** The ball's vertical bounce frequency increases for a limited time.
- [X] **Sink/Float:** Alters the ball's gravity/bounce height to access different paths.

### Level 1 Design: "The Basics"
- [ ] **Beat 1: Game Start & Level Intro**
    - [ ] A main menu screen appears with "1 Player" and "2 Player" options.
    - [ ] After selection, a "LEVEL 1" title card appears, showing the player's 3 lives.
- [ ] **Beat 2: Player Onboarding (Safe Zone)**
    - [ ] The level begins in a short, enclosed area with no hazards.
    - [ ] This space allows the player to safely get used to the automatic bouncing and the feel of the left/right controls.
- [ ] **Beat 3: First Obstacle**
    - [ ] The player encounters a short, simple stretch of floor spikes.
    - [ ] This section is designed to be passable with basic timing and teaches the player that hazards exist.
- [ ] **Beat 4: Power-Up Introduction**
    - [ ] The player encounters the "Slow Down" power-up (represented by a lock icon asset).
    - [ ] Upon collection, the ball changes color, the bounce speed visibly slows, and a timer appears on the HUD.
- [ ] **Beat 5: Power-Up Application**
    - [ ] The player faces a long corridor with spikes on both the ceiling and floor.
    - [ ] This section is intentionally very difficult or impossible at normal bounce speed, requiring the use of the "Slow Down" power-up to navigate safely.
- [ ] **Beat 6: Secret Area & Optional Challenge**
    - [ ] The player passes a section of the right-hand wall that has a subtle visual difference (e.g., a slightly different color or texture).
    - [ ] If the player holds the 'Right' key against this wall, they will pass through it into a hidden room. The screen goes black and they are transported to another room. 
    - [ ] Inside the secret room is one of the three "Golden Hoops" for the level.
    - [ ] The user exits the room by seeing that the rightmost wall of the room has the same subtle color change as before. When they press against it they are transported back to the regular path. 
- [ ] **Beat 7: Level Completion**
    - [ ] The main path ends with the level goal object: a net.
    - [ ] When the ball enters the net's hitbox, the level is marked as complete, and a "Level Clear" screen appears, showing the number of golden hoops collected.

## Design Requests
- [X] **Art Style:**
    - [X] TBD, but with a specific constraint: the floor and ceiling "lanes" the ball bounces between should be a calming red color.
- [X] **Sound Design & Music:**
    - [X] Satisfying "bop" sound on impact.
    - [X] Music with a strong, clear beat to complement the gameplay rhythm.
- [X] **UI/HUD (Heads-Up Display):**
    - [X] Clean and non-intrusive.
    - [X] Displays: number of lives, golden hoops collected, and a timer for active power-ups.

## Other Notes
- **Development Strategy & Stack:**
    - **Engine:** Godot Engine.
    - **Physics:** Utilize Godot's built-in 2D physics engine.
    - **State Management:** Global state (lives, score) will be managed using a Godot Autoload script (Singleton pattern).
    - **Focus:** Build the single-player version first.
- **Minimum Viable Product (MVP) Plan:**
    1. A single, non-scrolling screen.
    2. A ball that bounces automatically.
    3. Player can control horizontal movement.
    4. One hazard type (spikes).
    5. A "popped" state and a level restart mechanism.
- **Future Ideas / Suggestions:**
    - **Power-ups:** Invincibility/Shield, Shrink/Grow.
    - **Hazards:** Timed (retracting) spikes, simple tracking enemies, "sticky" surfaces.
    - **Multiplayer-Specific Challenges:** Co-op pressure plates, gated paths requiring teamwork.
    - **Networking:** When multiplayer is implemented, Godot's high-level networking API will be used.


    - Technical Architecture
    - Gameplay Design
    - Development Phases
    - Visual Style Guide


# Suggested Architecture for Level 1
    Initial Setup:
    - You have a MainMenu.tscn. When the player clicks "1 Player," you call get_tree().change_scene_to_file("res://scenes/levels/level_1.tscn"). This unloads the menu and loads your Level 1 scene.

    Inside level_1.tscn:
    - This scene is much larger than the screen. It might be 10,000 pixels wide, but your game window is only 1920.
    - Your Player.tscn instance is placed at the starting coordinates.
    - You add a Camera2D node as a child of the Player node. This is the simplest way to ensure the camera always follows the player as it moves through the large level.

    Here’s how the beats play out in this single, continuous level scene:
    - Beat 2: Onboarding (Safe Zone): This is just a section of your TileMap near the start of the level with no hazards "painted" on it. The Camera2D follows the player through this area.
    - Beat 3: First Obstacle: Further to the right in the TileMap, you have placed instances of Spike.tscn. The player moves into this area, and the physics engine handles the collision.
    - Beat 4 & 5: Power-Up: You place a PowerUp.tscn (an Area2D) in the level. When the player's RigidBody2D overlaps with it, a signal is emitted. The Player script catches this signal, enters its "Slow-Mo" state, and the UI updates. The long corridor of spikes is simply the next part of the TileMap design.
    - Beat 6: Secret Area: This is the most interesting architectural choice.
    The Bad Way: Changing to a new "secret room scene." This is complex because you need to save the exact state of the main level (positions of all moving objects, etc.) and restore it when you come back.
    The Industry Best Practice: The "secret room" is just another section of your TileMap built far away from the main path in the same level_1.tscn file (e.g., at coordinates far above or below the main level). When the player phases through the secret wall:
    The wall's script detects the player.
    It calls a function that instantly changes the player's global_position to the entrance of the secret room.
    The Camera2D, being a child, instantly moves with it.
    When they exit the secret room, their global_position is set back to where they were on the main path. This is simple, fast, and requires no complex state saving.
    - Beat 7: Level Completion: At the very end of the level, you place an Area2D for the net. When the player enters, it emits a level_complete signal. A global script listens for this, saves progress, and then calls get_tree().change_scene_to_file() to load either a "Level Clear" screen or the next level file (level_2.tscn).
</file>

<file path="_docs/physics.md">
The physics parameters you choose will define the entire "feel" of your game. Getting them right is the difference between a character that feels floaty and unresponsive versus one that feels tight, predictable, and fun.

Here is a breakdown of the key physics parameters you will use in Godot for "Bop," where to find them, and why they are important for your specific gameplay.

1. Project-Wide Physics Settings

        These settings form the foundation of your game's world. You'll set them once and rarely change them.

        Location: Project > Project Settings > Physics > 2d

        Parameter: Default Gravity

        What it is: The constant downward acceleration applied to all RigidBody2D nodes in your game. It's measured in pixels per second squared.

        Why it's important for "Bop": This, combined with your ball's Bounce property, dictates the fundamental "metronomic pace" of your game. A higher value means faster falling and sharper, quicker bounces. A lower value will feel more "floaty."

        Recommended Starting Value: A good starting point is Godot's default of 980. You can increase it to 1200 or higher for a "tighter" feel, or lower it for a "softer" feel.

        Parameter: Default Linear Damp

        What it is: A default "friction" or "drag" applied to all physics bodies.

        Why it's important for "Bop": It's generally better to leave this at 0 and set damping on individual bodies instead, giving you more control.

2. The Player Ball (RigidBody2D) Parameters

        This is where you'll do most of your tuning. Select your Player.tscn's root RigidBody2D node to find these in the Inspector.

        Parameter: Mass

        What it is: The object's inertia.

        Why it's important for "Bop": In a single-player game where only one ball exists, Mass has very little effect. However, for your future multiplayer mode, it will determine how two balls interact if they collide. For now, leave it at 1.

        Parameter: Gravity Scale

        What it is: A multiplier for the project's Default Gravity. A value of 1 means normal gravity. 2 means double gravity. 0 means no gravity. -1 means it will fall up.

        Why it's important for "Bop": This is essential for your "Sink/Float" power-up.

        Normal State: Gravity Scale = 1.0

        Float Power-up: Set Gravity Scale to 0.5 or 0.7 to make the ball fall slower and have longer, higher bounces.

        Sink Power-up: Set Gravity Scale to 1.5 or 2.0 to make the ball fall faster and have shorter, quicker bounces.

        Parameter: Linear > Damping

        What it is: This property simulates air resistance or friction. It makes an object slow down and come to a stop on its own. A value of -1 uses the project default, 0 means no damping (it will slide forever, like on ice), and higher values increase the drag.

        Why it's important for "Bop": This is the key to achieving the "slight acceleration and deceleration" you want. If Damping is 0, the ball will stop moving horizontally the instant the player releases the key. If you set it to a small value like 0.5 or 1, the ball will smoothly slide to a stop, feeling much less abrupt.

        Resource: Physics Material

        What it is: This is a separate resource you create and assign to the RigidBody2D. It controls how the object behaves when it collides with other objects.

        Parameter: Bounce

        What it is: A value from 0 to 1 representing how much energy is conserved after a collision. 0 means the object stops dead (like a beanbag). 1 means it bounces back with 100% of its energy.

        Why it's important for "Bop": This is the heart of your game. You'll want a high value like 1 to maintain the constant bouncing. In practice, you might use 0.99 to prevent any weird physics bugs from adding energy over time. You can also modify this property for power-ups.

        Parameter: Friction

        What it is: Determines how much an object's velocity is affected by sliding along another object. 0 is like ice, 1 is like sandpaper.

        Why it's important for "Bop": You will likely want this to be very low (0 or 0.1). You want the player to have full control over horizontal movement. High friction would cause the ball to slow down horizontally every time it scrapes the floor, which would feel unresponsive.

3. Environment and Hazard Parameters

        Different objects in your scene need to behave differently. This is controlled by their Body Type.

        Object Type: StaticBody2D

        Used for: Your floors, ceilings, walls, and any non-moving spikes.

        Key Property: These bodies do not move. They are infinitely heavy and are not affected by gravity or collisions. They are the immovable foundation of your level. Their Physics Material can also have Friction and Bounce properties to affect how the player interacts with them.

        Object Type: AnimatableBody2D

        Used for: Your moving hazards like the vertically moving knife/crusher or the rotating blade.

        Key Property: This body type is not controlled by the physics engine (gravity doesn't affect it), but it does affect other physics bodies when it moves. You move it from your code using a Tween or an AnimationPlayer. This is perfect for objects that need to follow a predictable, non-physical path while still being a dangerous obstacle.

4. Collision System Parameters

        These aren't physics properties, but they are critical for making the physics work correctly.

        Location: Select any physics body, and in the Inspector, find the Collision section.

        Parameters: Layer and Mask

        What they are: Layer is the category an object belongs to. Mask is the categories an object looks for to collide with.

        Why it's important for "Bop": This allows you to control what interacts with what. For example:

        Player: Belongs to the "player" layer. Its mask should include "world," "hazards," and "collectibles."

        Spike: Belongs to the "hazards" layer. Its mask only needs to include "player." This is an important optimization—you don't need to check if a spike is colliding with another spike.

        Golden Hoop: Belongs to the "collectibles" layer. Its mask only needs to include "player."
</file>

<file path="_docs/SFX.md">
Based on your `SFX` folder, let's create a clear architectural guide for sound in "Bop".

### Core Principles of Sound Architecture

1.  **Centralize Control:** You should be able to control all your sounds from one single place. This makes implementing a volume slider in your settings menu trivial.
2.  **Decouple Logic from Sound:** Your player's code should not be responsible for managing sound files. It should simply say, "I died, play the death sound." It shouldn't know *what* that sound is or how it's played.
3.  **Separate Music and Sound Effects:** Background music and short, one-off sound effects should be treated differently so they can be controlled independently.

---

### The Best Practice: Create a "SoundManager" Singleton

The standard and most effective way to handle audio in Godot is to create a global "SoundManager." This is a script that is always running in the background (an Autoload) and its only job is to play the correct audio when asked.

Here is how you set it up and the rules to follow:

#### Step 1: Create the SoundManager Scene

1.  Create a new scene. Click `Scene` -> `New Scene`.
2.  Choose a `Node` as the root and rename it to `SoundManager`.
3.  Add two child nodes to `SoundManager`:
    *   An **`AudioStreamPlayer`**, rename it to **`MusicPlayer`**.
    *   Another **`AudioStreamPlayer`**, rename it to **`SfxPlayer`**.

This structure allows you to play long-running music on one player and fire off short sound effects on the other without them interrupting each other.

#### Step 2: Create the SoundManager Script

1.  Select the `SoundManager` root node.
2.  Attach a new script to it called `SoundManager.gd`.
3.  Paste the following code into the script. This code is your rulebook.

```gdscript
# SoundManager.gd

extends Node

# Get references to our audio player nodes in the scene tree.
@onready var music_player = $MusicPlayer
@onready var sfx_player = $SfxPlayer

# --- YOUR SOUND LIBRARY ---
# This dictionary maps a simple name to a preloaded sound file.
# This is the ONLY place you should reference sound file paths.
var sfx_library = {
    "pop": preload("res://SFX/pop.mp3"),
    "bounce": preload("res://SFX/bounce.mp3"),
    "coin": preload("res://SFX/coins.mp3"),
    "success": preload("res://SFX/success.mp3")
}

var music_track = preload("res://SFX/Balloon Escape Factory.mp3")


# --- YOUR RULES / FUNCTIONS ---

# Rule 1: Use this function to play any one-off sound effect.
func play_sfx(sound_name: String):
    # Check if the sound name exists in our library to avoid errors.
    if sfx_library.has(sound_name):
        sfx_player.stream = sfx_library[sound_name]
        sfx_player.play()
    else:
        print("Error: Sound effect not found in library: ", sound_name)

# Rule 2: Use this function to play the background music.
func play_music():
    music_player.stream = music_track
    music_player.play()

# Rule 3: Use this to stop the music (e.g., on a game over screen).
func stop_music():
    music_player.stop()

# Rule 4: Add functions to control volume centrally.
# This is where your settings menu would connect.
func set_master_volume(volume_db: float):
    # Godot's audio buses are controlled in decibels.
    AudioServer.set_bus_volume_db(0, volume_db)

func set_sfx_volume(volume_db: float):
    # You can create custom buses for SFX and Music for finer control.
    # For now, we'll just control the individual players.
    sfx_player.volume_db = volume_db

func set_music_volume(volume_db: float):
    music_player.volume_db = volume_db
```

#### Step 3: Make the SoundManager Global (Autoload)

1.  Go to `Project` -> `Project Settings...`.
2.  Click on the **`Autoload`** tab.
3.  Click the folder icon next to the "Path" text field and select your `SoundManager.tscn` file.
4.  Make sure the "Enable" checkbox is ticked.
5.  Click **"Add"**.

Now, your `SoundManager` will be available everywhere in your code, globally.

---

### How to Use Your Sound Rules in Your Game Code

Now, instead of adding `AudioStreamPlayer` nodes to your player or coins, you just call the `SoundManager`.

**Example: In your Player's death function:**

```gdscript
# in player.gd

func on_death():
    # The Wrong Way:
    # $MyOwnPopSoundPlayer.play()  # This is hard to manage and control.

    # The Right Way:
    # Just tell the SoundManager what to do. No file paths needed here!
    SoundManager.play_sfx("pop")

    # The player's code is clean. It doesn't know about pop.mp3,
    # it only knows it needs to play the "pop" sound.
    queue_free()
```

**Example: When you collect a coin:**

```gdscript
# in coin.gd

func on_collected():
    SoundManager.play_sfx("coin")
    queue_free()
```

**Example: When the level starts:**

```gdscript
# in level_1.gd

func _ready():
    SoundManager.play_music()
```

By following these rules, if you ever want to change the "pop" sound, you only have to change it in **one place**: the `sfx_library` inside `SoundManager.gd`. If you want to add a volume slider, you just need to connect it to the `set_sfx_volume` and `set_music_volume` functions in your `SoundManager`. Your architecture is now clean, manageable, and ready to scale.
</file>

<file path="_docs/style.md">
Here is a visual style guide for "Bop" based on your project plan and the assets you have gathered.

## Use Export Variables for Everything Visual

        Never hardcode asset file paths in your code. Instead, create a variable for the asset and use the @export keyword.

        Don't build your player, enemies, or power-ups directly in your main level scene. Create a dedicated scene for each reusable object.

        Example
        in player.gd

        @export var player_texture : Texture2D
        @export var pop_sound : AudioStream

        func _ready():
        # The code doesn't know or care what the texture is. It just uses it.
        $Sprite2D.texture = player_texture

        func on_death():
        # The code doesn't care which sound file it's playing.
        $AudioStreamPlayer.stream = pop_sound
        $AudioStreamPlayer.play()

        Example Player.tscn

        RigidBody2D (this is the root, with player.gd script attached)

        Sprite2D (this displays the texture)

        CollisionShape2D (this defines the physics hitbox)

        AudioStreamPlayer (for the pop sound)

## Bop - Visual Style Guide

This document outlines the visual direction for the game "Bop," using the assets available in the project's assets folder.

1. Core Principles

Contrasting Styles: The game will blend realistically textured environment elements (wood, stone) with a clean, glossy player character. This contrast will make the player character stand out clearly against the background.

Color-Coded Surfaces: The primary interactive surfaces (the floor and ceiling the ball bounces between) will be visually distinct. As requested, they will be tinted a calming red color in-engine to create a consistent "lane" for the player.

Clear Visual Hierarchy: Hazards, collectibles, and interactive elements will use bright, distinct visuals to be instantly recognizable to the player.

2. Player Character

The player character is the central focus and should always be easy to see.

Sprite: The player will be represented by player/ball.png.

Death Effect: Upon collision with a hazard, the player sprite will instantly disappear. In its place, the word "Pop!" will appear briefly in a large, playful font before the level restarts or a life is deducted.

Power-Up State: When the player collects a power-up, the ball.png sprite will have its color modulated in-engine for the duration of the effect. For example, blue for "Slow Down," yellow for "Speed Up," etc.
"Pop!" Effect Style: use the font in the font folder for this

3. Environment & Level Design

The world is built from a mix of textured and simple blocks to guide the player.

Main Surfaces (Floor, Ceiling, Walls): The core building blocks of the level will be the textured tiles.

Use environment/ground_stone.png and environment/ground_wood.png as the primary TileSet materials.

In Godot: These floor and ceiling tiles will be modulated to a uniform red color to create the visual "lane." Normal walls will remain their default texture color.

Secret Tunnel Walls: To make secret areas discoverable but not obvious, specific wall sections will use a visually distinct tile.

Asset: Use environment/platformPack_tile034.png (the simple blue block) for these walls.

Implementation: In-engine, this tile will be modulated to a slightly different shade of the main wall's color (e.g., a slightly paler or darker stone/wood color). This creates the "subtle visual difference" required. The player must press against this wall for a moment to trigger entry.

Background: The game background will use background/bg_layer1.png. To add depth, this layer should scroll at a slightly slower speed than the foreground (a parallax effect).

4. Hazards

Hazards must be immediately identifiable as dangerous.

Static Spikes: Spikes will be placed on the floor and ceiling.

Ceiling Spikes: Use the hazards/spike_top.png asset.

Floor Spikes: Use the hazards/spike_bottom.png asset.

Moving Hazards: The rotating blade and moving crusher will need to be created from other assets or a new, simple shape in-engine, as there are no direct sprites for them in the current asset list.

5. Collectibles & Power-ups

These items should be bright, enticing, and feel rewarding to collect.

Golden Coins: The three optional collectibles per level.

Animation: Use the sequence collectibles_and_powerups/gold_1.png, gold_2.png, and gold_3.png in an AnimatedSprite2D to create a spinning coin effect.

Power-ups: All power-up items will float in place with a gentle up-and-down motion (using a Tween or AnimationPlayer) to make them feel dynamic.

Slow Down / Power-up The collectibles_and_powerups/jetpack.png is a perfect visual representation for a power-up that alters the player's vertical movement.

6. Heads-Up Display (HUD) & UI

The HUD should be clean, clear, and provide essential information without cluttering the screen.

Lives Display: The player's remaining lives will be displayed in the top-left corner of the screen.

Asset: Use the ui/lives_coin_bronze.png asset as the icon for a life.

Implementation: Display the icon followed by a number (e.g., "x 3"). This number will be 3 for single-player and 5 for multiplayer.

The secret walls will use a very simple, flat-shaded block (platformPack_tile034.png) while the main environment uses more detailed, textured wood and stone.
</file>

<file path=".cursor/rules/godot.mdc">
---
alwaysApply: true
---

## Core Development Guidelines

- Use strict typing in GDScript for better error detection and IDE support
- Implement \_ready() and other lifecycle functions with explicit super() calls
- Use @onready annotations instead of direct node references in \_ready()
- Prefer composition over inheritance where possible
- Use signals for loose coupling between nodes
- Follow Godot's node naming conventions (PascalCase for nodes, snake_case for methods)

## Code Style

- Use type hints for all variables and function parameters
- Document complex functions with docstrings
- Keep methods focused and under 30 lines when possible
- Use meaningful variable and function names
- Group related properties and methods together

## Naming Conventions

- Files: Use snake_case for all filenames (e.g., player_character.gd, main_menu.tscn)
- Classes: Use PascalCase for custom class names with class_name (e.g., PlayerCharacter)
- Variables: Use snake_case for all variables including member variables (e.g., health_points)
- Constants: Use ALL_CAPS_SNAKE_CASE for constants (e.g., MAX_HEALTH)
- Functions: Use snake_case for all functions including lifecycle functions (e.g., move_player())
- Enums: Use PascalCase for enum type names and ALL_CAPS_SNAKE_CASE for enum values
- Nodes: Use PascalCase for node names in the scene tree (e.g., PlayerCharacter, MainCamera)
- Signals: Use snake_case in past tense to name events (e.g., health_depleted, enemy_defeated)

## Scene Organization

- Keep scene tree depth minimal for better performance
- Use scene inheritance for reusable components
- Implement proper scene cleanup on queue_free()
- Use SubViewport nodes carefully due to performance impact
- Provide step-by-step instructions to create Godot scene(s) instead of providing scene source code

## Signal Best Practices

- Use clear, contextual signal names that describe their purpose (e.g., player_health_changed)
- Utilize typed signals to improve safety and IDE assistance (e.g., signal item_collected(item_name: String))
- Connect signals in code for dynamic nodes, and in the editor for static relationships
- Avoid overusing signals - reserve them for important events, not frequent updates
- Pass only necessary data through signal arguments, avoiding entire node references when possible
- Use an autoload "EventBus" singleton for global signals that need to reach distant nodes
- Minimize signal bubbling through multiple parent nodes
- Always disconnect signals when nodes are freed to prevent memory leaks
- Document signals with comments explaining their purpose and parameters

## Resource Management

- Implement proper resource cleanup in \_exit_tree()
- Use preload() for essential resources, load() for optional ones
- Consider PackedByteArray storage impact on backwards compatibility
- Implement resource unloading for unused assets

## Performance Best Practices

- Use node groups judiciously for managing collections, and prefer direct node references for frequent, specific access to individual nodes.
- Implement object pooling for frequently spawned objects
- Use physics layers to optimize collision detection
- Prefer packed arrays (PackedVector2Array, etc.) over regular arrays

## Error Handling

- Implement graceful fallbacks for missing resources
- Use assert() for development-time error checking
- Log errors appropriately in production builds
- Handle network errors gracefully in multiplayer games

## TileMap Implementation
- Build Levels with TileMapLayer. TileMap node is deprecated - use multiple TileMapLayer nodes instead
- Create a TileSet resource: A TileSet is a collection of tiles that you create from a spritesheet 
- Use a TileMap node: In your level scene, add a TileMap node and assign your TileSet resource to it.
- Convert existing TileMaps using the TileMap bottom panel toolbox option "Extract TileMap layers"
- Access TileMap layers through TileMapLayer nodes
- Update navigation code to use TileMapLayer.get_navigation_map()
- Store layer-specific properties on individual TileMapLayer nodes


## Theme and UI
- Create a Theme resource: Go to the Inspector for your root UI node (e.g., a Control or CanvasLayer node). In the theme property, click <empty> and New Theme
- Define UI style: In this theme, you can set the default font, font size, font color, etc., for all Label nodes, Button nodes, and more
- For HUD (lives, score) and menus etc., don't set the font and color on every single Label node individually.

    # Example file system for Assets and UI

    assets/
        audio/
        fonts/
        placeholder_art/
        jumper_pack/
        simplified_pack/
        final_art/ (empty for now)
    scenes/
        player/
        player.tscn
        player.gd
        levels/
        ui/

## Use Export Variables for Everything Visual
- Never hardcode asset file paths in your code. Instead, create a variable for the asset and use the @export keyword. 
- Don't build your player, enemies, or power-ups directly in your main level scene. Create a dedicated scene for each reusable object.

    # Example
    # in player.gd
    @export var player_texture : Texture2D
    @export var pop_sound : AudioStream

    func _ready():
        # The code doesn't know or care what the texture is. It just uses it.
        $Sprite2D.texture = player_texture

    func on_death():
        # The code doesn't care which sound file it's playing.
        $AudioStreamPlayer.stream = pop_sound
        $AudioStreamPlayer.play()


    # Example Player.tscn
    - RigidBody2D (this is the root, with player.gd script attached)
        - Sprite2D (this displays the texture)
        - CollisionShape2D (this defines the physics hitbox)
        - AudioStreamPlayer (for the pop sound)

## State Machine
    - You define all possible states (e.g., NORMAL, SLOW_MO, DEAD).
    - Your _physics_process loop's only job is to call the function for the current state (e.g., state_machine.update()).
    - Each state has its own logic. The NORMAL state handles regular bouncing. The SLOW_MO state handles slower bouncing.
    - You define clear transitions (e.g., picking up a power-up transitions you from NORMAL to SLOW_MO).


    # Example State Machine scripts
        #state.gd
            class_name State
            extends Node

            @export
            var animation_name: String
            @export
            var move_speed: float = 400

            var gravity: int = ProjectSettings.get_setting("physics/2d/default_gravity")

            ## Hold a reference to the parent so that it can be controlled by the state
            var parent: Player

            func enter() -> void:
                parent.animations.play(animation_name)

            func exit() -> void:
                pass

            func process_input(event: InputEvent) -> State:
                return null

            func process_frame(delta: float) -> State:
                return null

            func process_physics(delta: float) -> State:
                return null

        extends Node

    #state_machine.gd
        @export
        var starting_state: State

        var current_state: State

        # Initialize the state machine by giving each child state a reference to the
        # parent object it belongs to and enter the default starting_state.
        func init(parent: Player) -> void:
            for child in get_children():
                child.parent = parent

            # Initialize to the default state
            change_state(starting_state)

        # Change to the new state by first calling any exit logic on the current state.
        func change_state(new_state: State) -> void:
            if current_state:
                current_state.exit()

            current_state = new_state
            current_state.enter()
            
        # Pass through functions for the Player to call,
        # handling state changes as needed.
        func process_physics(delta: float) -> void:
            var new_state = current_state.process_physics(delta)
            if new_state:
                change_state(new_state)

        func process_input(event: InputEvent) -> void:
            var new_state = current_state.process_input(event)
            if new_state:
                change_state(new_state)

        func process_frame(delta: float) -> void:
            var new_state = current_state.process_frame(delta)
            if new_state:
                change_state(new_state)

    #state_machine.tscn
        [gd_scene load_steps=2 format=3 uid="uid://bsgtr5x44hma2"]

        [ext_resource type="Script" path="res://src/state_machine/state_machine.gd" id="1_3qyia"]

        [node name="state_machine" type="Node"]
        script = ExtResource("1_3qyia")


## Physics
    Guideline: Go to Project > Project Settings > Layer Names > 2D Physics. Name your first few layers: world, player, hazards, collectible, phasewall. Then, in the Inspector for each scene (Player.tscn, Spike.tscn, etc.), assign them to their correct layer and, most importantly, set their Mask. The Mask tells an object what layers it "listens" to for collisions. The player should listen to world, hazards, and collectible, but a collectible only needs to listen to the player.

## Groups for broad communication
    - Put all your hazards in a "hazard" group. When your player hits something, you can check if that object is_in_group("hazard") instead of checking its specific name or type. This is incredibly flexible.
    - Guideline: Use Groups to ask "What kind of thing are you?" not "Who are you?" When your player's body collides with something, the code should not be if body.name == "Spike" or if body is Spike. It should be if body.is_in_group("hazards").
    Action: Add your Spike.tscn, Crusher.tscn, and RotatingBlade.tscn to the "hazards" group in the Node panel. This way, you can create a dozen new types of hazards, and your player's collision code will work for all of them without a single change.

## Global Event Bus
    - For events that many different parts of the game might care about (like player_died or hoop_collected), have your GameState Autoload act as an "Event Bus." It can define signals (signal player_died), and other nodes can connect to them. This prevents nodes from having to know about each other directly, which is a very robust and decoupled design.
    - Guideline: Nodes should announce what happened to them, not command other nodes. A node should never have to get a reference to another node to tell it something. 
        Action: In GameState.gd, define signals like signal player_died, signal hoop_collected(value), signal powerup_activated(type).
        Wrong: get_node("/root/Main/UI").update_hoop_count(new_total)
        Right: The hoop, upon collection, calls GameState.emit_signal("hoop_collected", 1). The UI script, in its _ready() function, connects to this signal: GameState.hoop_collected.connect(self.on_hoop_collected). This way, the UI and the hoop don't know about each other at all; they only know about the global game state.

#Resource Files for Data
    - For things like your 5 levels, don't hardcode enemy positions in Level.tscn. Create your own custom Resource type (e.g., LevelData.tres) that stores the positions and types of enemies for each level. Your Level.tscn then just loads the correct resource and uses that data to build the scene. This separates your game's data from its logic, making it much easier to edit levels.
    - Guideline: Your code should define behavior. Your Resources should define data. Your level scenes should be as "dumb" as possible. Action: Create a new script that extends Resource. Call it LevelData.gd. In it, define exported variables: @export var spike_positions : Array[Vector2], @export var powerup_data : Array[Dictionary], @export var level_goal_position : Vector2. For each level, create a new LevelData resource file (level_1.tres, level_2.tres, etc.). Click on it and fill in all the data in the Inspector. Your main Level.tscn script will have one @export var level_data : LevelData. You just drag your desired .tres file into it. The script then reads this data and programmatically places the spikes and power-ups. Now you can design dozens of levels without ever changing your core level scene code.
</file>

<file path=".cursor/rules/multiplayer.mdc">
---
description: Whenever core functionality of the codebase is being set up check this multiplayer rule and apply guidelines if code changes are relevan tto multiplayer
alwaysApply: false
---


Godot Multiplayer Architecture Guide for "Bop"

This document outlines the core architectural decisions and best practices for implementing multiplayer in the game "Bop" using Godot's High-Level Multiplayer API.

High-Level vs. Low-Level API: The Decision

For "Bop", we will exclusively use the High-Level Multiplayer API.

Why? It is simpler, less error-prone, and specifically designed for the kind of real-time game state synchronization that "Bop" requires. It allows us to focus on game logic rather than networking boilerplate. While the Low-Level API offers more control, the High-Level API provides the best balance of performance, stability, and development speed for this project.

The Core Principle: Server Authority

Before any code is written, every decision must follow this rule: The Server is the Law.

In a 2-player game, one player will act as the host (server) and the other will be the client. The server's computer is the single source of truth for the game state (player positions, score, lives, etc.). The client sends its input to the server and then displays the state that the server sends back. This architecture is essential for preventing cheating and keeping the game state perfectly synchronized between players.

Key Implementation Guidelines

Here are the four essential guidelines for building "Bop" with Godot's High-Level Multiplayer API.

## Guideline 1: Use MultiplayerSpawner for All Networked Objects

        Problem: How do we create a Player object on the server and ensure the client also creates the exact same Player object and links them together?

        Solution: Never use add_child() directly for networked objects. Use a MultiplayerSpawner as the single point of entry for any object that needs to exist on both screens.

        How to Implement:

        In your Level.tscn, create a single node of type MultiplayerSpawner.

        In the Inspector for this node, add your Player.tscn to its list of spawnable scenes.

        When a new player connects, the server's code will call multiplayer_spawner.spawn(player_scene) instead of add_child().

        Godot's multiplayer API will automatically handle creating the player on the server, creating a corresponding player on all clients, and linking them across the network.

## Guideline 2: Use RPCs for Player Input (Intent), Not State

        Problem: How does the client tell the server they want to move left or right?

        Solution: The client calls a Remote Procedure Call (RPC) to announce its intent to move. It should never tell the server its new position directly.

        How to Implement:

        In your Player.gd script, create a function to receive input and mark it with the @rpc annotation. This tells Godot that this function can be called over the network.

        Generated gdscript
        # In Player.gd
        # This function is designed to be called remotely BY a client ON the server.
        # "call_local" also runs it on the client for immediate feedback (client-side prediction).
        @rpc("call_local", "reliable")
        func set_player_input(horizontal_intent: float):
            # The server uses this value to move the authoritative player body.
            # The client uses this value for its local prediction.
            self.direction = horizontal_intent


        In the _physics_process loop, only the player who owns the character can send their input.

        Generated gdscript
        # In Player.gd, inside _physics_process(delta)
        func _physics_process(delta):
            if is_multiplayer_authority(): # This is true only for the player you control.
                var input_direction = Input.get_axis("move_left", "move_right")
                # This RPC is sent to the server automatically because of the @rpc annotation.
                set_player_input(input_direction)

            # ... rest of physics movement code using self.direction ...
    

        The Golden Rule: A client should never send an RPC like update_my_position(new_pos). It should only send i_am_pressing_this_button().

## Guideline 3: Use MultiplayerSynchronizer for Continuous State

        Problem: The ball is constantly bouncing. Sending its position 60 times a second via RPCs would flood the network.

        Solution: Use the MultiplayerSynchronizer node to automatically and efficiently sync properties like position.

        How to Implement:

        Add a MultiplayerSynchronizer node as a child of your Player.tscn.

        In the Inspector for this node, under the "Replicated Properties" section, add the position property of the parent Player node.

        The synchronizer will now watch the position of the server's version of the Player. It will automatically send updates to all clients when it changes.

        The clients' synchronizers receive this data and smoothly interpolate their local "ghost" of the player to match the server's authoritative position, making movement look smooth even with network latency.

## Guideline 4: Use RPCs for Discrete, One-Off Events

        Problem: What happens when the ball hits a spike, collects a hoop, or uses a power-up? These are instantaneous events, not continuous states.

        Solution: Use RPCs for these single, important game moments. The server will handle the logic and then call an RPC to tell all clients to play the corresponding visual and audio effects.

        How to Implement:

        Collision checks and game logic only run on the server.

        When the server detects a player has died, it handles the logic (lives -= 1) and then calls an RPC to trigger the "Pop!" effect on all clients.

        Generated gdscript
        # In Player.gd (or wherever hazard collision logic lives)

        # This function is called on the server when a collision with a hazard is detected.
        func handle_death():
            if not is_multiplayer_authority(): return # Only the server can process death.

            # 1. Server handles the core game logic.
            get_tree().get_first_node_in_group("game_state").player_died(self.owner_id)

            # 2. Server tells all clients to play the visual effect at the death location.
            play_pop_effect_rpc.rpc(self.global_position)

            # 3. Server destroys its authoritative copy of the player.
            self.queue_free()

        # This function is designed to be called BY the server ON ALL clients.
        @rpc("any_peer", "reliable")
        func play_pop_effect_rpc(location: Vector2):
            # Code to instance a particle effect/animation scene at the given location.
            # This ensures all players see the "Pop!" at the same time and place.
            var pop_effect = load("res://scenes/effects/pop_effect.tscn").instantiate()
            get_tree().root.add_child(pop_effect)
            pop_effect.global_position = location
</file>

<file path=".cursor/rules/physics.mdc">
---
alwaysApply: true
---
The physics parameters you choose will define the entire "feel" of your game. Getting them right is the difference between a character that feels floaty and unresponsive versus one that feels tight, predictable, and fun.

Here is a breakdown of the key physics parameters you will use in Godot for "Bop," where to find them, and why they are important for your specific gameplay.

1. Project-Wide Physics Settings

        These settings form the foundation of your game's world. You'll set them once and rarely change them.

        Location: Project > Project Settings > Physics > 2d

        Parameter: Default Gravity

        What it is: The constant downward acceleration applied to all RigidBody2D nodes in your game. It's measured in pixels per second squared.

        Why it's important for "Bop": This, combined with your ball's Bounce property, dictates the fundamental "metronomic pace" of your game. A higher value means faster falling and sharper, quicker bounces. A lower value will feel more "floaty."

        Recommended Starting Value: A good starting point is Godot's default of 980. You can increase it to 1200 or higher for a "tighter" feel, or lower it for a "softer" feel.

        Parameter: Default Linear Damp

        What it is: A default "friction" or "drag" applied to all physics bodies.

        Why it's important for "Bop": It's generally better to leave this at 0 and set damping on individual bodies instead, giving you more control.

2. The Player Ball (RigidBody2D) Parameters

        This is where you'll do most of your tuning. Select your Player.tscn's root RigidBody2D node to find these in the Inspector.

        Parameter: Mass

        What it is: The object's inertia.

        Why it's important for "Bop": In a single-player game where only one ball exists, Mass has very little effect. However, for your future multiplayer mode, it will determine how two balls interact if they collide. For now, leave it at 1.

        Parameter: Gravity Scale

        What it is: A multiplier for the project's Default Gravity. A value of 1 means normal gravity. 2 means double gravity. 0 means no gravity. -1 means it will fall up.

        Why it's important for "Bop": This is essential for your "Sink/Float" power-up.

        Normal State: Gravity Scale = 1.0

        Float Power-up: Set Gravity Scale to 0.5 or 0.7 to make the ball fall slower and have longer, higher bounces.

        Sink Power-up: Set Gravity Scale to 1.5 or 2.0 to make the ball fall faster and have shorter, quicker bounces.

        Parameter: Linear > Damping

        What it is: This property simulates air resistance or friction. It makes an object slow down and come to a stop on its own. A value of -1 uses the project default, 0 means no damping (it will slide forever, like on ice), and higher values increase the drag.

        Why it's important for "Bop": This is the key to achieving the "slight acceleration and deceleration" you want. If Damping is 0, the ball will stop moving horizontally the instant the player releases the key. If you set it to a small value like 0.5 or 1, the ball will smoothly slide to a stop, feeling much less abrupt.

        Resource: Physics Material

        What it is: This is a separate resource you create and assign to the RigidBody2D. It controls how the object behaves when it collides with other objects.

        Parameter: Bounce

        What it is: A value from 0 to 1 representing how much energy is conserved after a collision. 0 means the object stops dead (like a beanbag). 1 means it bounces back with 100% of its energy.

        Why it's important for "Bop": This is the heart of your game. You'll want a high value like 1 to maintain the constant bouncing. In practice, you might use 0.99 to prevent any weird physics bugs from adding energy over time. You can also modify this property for power-ups.

        Parameter: Friction

        What it is: Determines how much an object's velocity is affected by sliding along another object. 0 is like ice, 1 is like sandpaper.

        Why it's important for "Bop": You will likely want this to be very low (0 or 0.1). You want the player to have full control over horizontal movement. High friction would cause the ball to slow down horizontally every time it scrapes the floor, which would feel unresponsive.

3. Environment and Hazard Parameters

        Different objects in your scene need to behave differently. This is controlled by their Body Type.

        Object Type: StaticBody2D

        Used for: Your floors, ceilings, walls, and any non-moving spikes.

        Key Property: These bodies do not move. They are infinitely heavy and are not affected by gravity or collisions. They are the immovable foundation of your level. Their Physics Material can also have Friction and Bounce properties to affect how the player interacts with them.

        Object Type: AnimatableBody2D

        Used for: Your moving hazards like the vertically moving knife/crusher or the rotating blade.

        Key Property: This body type is not controlled by the physics engine (gravity doesn't affect it), but it does affect other physics bodies when it moves. You move it from your code using a Tween or an AnimationPlayer. This is perfect for objects that need to follow a predictable, non-physical path while still being a dangerous obstacle.

4. Collision System Parameters

        These aren't physics properties, but they are critical for making the physics work correctly.

        Location: Select any physics body, and in the Inspector, find the Collision section.

        Parameters: Layer and Mask

        What they are: Layer is the category an object belongs to. Mask is the categories an object looks for to collide with.

        Why it's important for "Bop": This allows you to control what interacts with what. For example:

        Player: Belongs to the "player" layer. Its mask should include "world," "hazards," and "collectibles."

        Spike: Belongs to the "hazards" layer. Its mask only needs to include "player." This is an important optimization—you don't need to check if a spike is colliding with another spike.

        Golden Hoop: Belongs to the "collectibles" layer. Its mask only needs to include "player."
</file>

<file path=".godot/import_md5.md5">
source_file="res://project.godot"
dest_files=[]
</file>

<file path="project.godot">
; Engine configuration file.
; It's best edited using the editor UI and not directly,
; since the parameters that go here are not all obvious.
;
; Format:
;   [section] ; section goes between []
;   param=value ; assign values to parameters

config_version=5

[application]

config/name="Bop"
config/description="A 2D rhythm-based platformer where the player controls the horizontal movement of a constantly bouncing ball."
run/main_scene="res://scenes/player/player.tscn"
config/features=PackedStringArray("4.3")
config/icon="res://BopAssets/assets/player/ball.png"

[autoload]

SoundManager="*res://scripts/singletons/SoundManager.tscn"
GameState="*res://scripts/singletons/GameState.gd"

[display]

window/size/viewport_width=1920
window/size/viewport_height=1080
window/stretch/mode="canvas_items"
window/stretch/aspect="expand"

[input]

ui_accept={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194309,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":32,"key_label":0,"unicode":32,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":0,"pressure":0.0,"pressed":true,"script":null)
]
}
ui_cancel={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194305,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
, Object(InputEventJoypadButton,"resource_local_to_scene":false,"resource_name":"","device":-1,"button_index":1,"pressure":0.0,"pressed":true,"script":null)
]
}
move_left={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":65,"key_label":0,"unicode":97,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194319,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
]
}
move_right={
"deadzone": 0.5,
"events": [Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":68,"key_label":0,"unicode":100,"location":0,"echo":false,"script":null)
, Object(InputEventKey,"resource_local_to_scene":false,"resource_name":"","device":-1,"window_id":0,"alt_pressed":false,"shift_pressed":false,"ctrl_pressed":false,"meta_pressed":false,"pressed":false,"keycode":0,"physical_keycode":4194321,"key_label":0,"unicode":0,"location":0,"echo":false,"script":null)
]
}

[layer_names]

2d_physics/layer_1="world"
2d_physics/layer_2="player"
2d_physics/layer_3="hazards"
2d_physics/layer_4="collectibles"
2d_physics/layer_5="phasewall"

[physics]

2d/default_gravity=980
2d/default_linear_damp=0.0

[rendering]

textures/canvas_textures/default_texture_filter=0
environment/defaults/default_clear_color=Color(0.301961, 0.301961, 0.301961, 1)
</file>

</files>
